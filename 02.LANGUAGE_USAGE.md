# Language Usage

## General Usage

### G-1010: Intenta etiquetar tus sub-bloques

Intenta etiquetar tus sub bloques, ya que es una buena alternativa para que los comentarios indiquen el inicio y el final de un procesamiento con nombre.

#### Ejemplo sub-bloques

```sql
BEGIN
   <<prepare_data>>
   BEGIN
      NULL;
   END prepare_data;

   <<process_data>>
   BEGIN
      NULL;
   END process_data;
END good;
/
```

### G-1020: Siempre tenga una etiqueta de bucle o bloque coincidente

La razón de usar Utilice una etiqueta directamente delante de bucles y bloques anónimos anidados es:

- Dar un nombre a esa porción de código y por lo tanto auto-documentar lo que está haciendo.

- Para que pueda repetir ese nombre con la instrucción END de ese bloque o bucle.

```sql
DECLARE
   i INTEGER;
   co_min_value CONSTANT INTEGER := 1;
   co_max_value CONSTANT INTEGER := 10;
   co_increment CONSTANT INTEGER := 1;
BEGIN
   <<prepare_data>>
   BEGIN
      NULL;
   END prepare_data;

   <<process_data>>
   BEGIN
      NULL;
   END process_data;

   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value)
   LOOP
      i := i + co_increment;
   END LOOP while_loop;

   <<basic_loop>>
   LOOP
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP
     sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/
```

### G-1030: Avoid defining variables that are not used

Evite definir variables que no se utilicen

### G-1040: Evitar el código muerto

Cualquier parte de su código, que ya no se usa o no se puede alcanzar, debe eliminarse de sus programas para simplificar el código.

### G-1050: Evita usar literales en tu código

Los literales a menudo se usan más de una vez en su código. Tenerlos definidos como una constante reduce los errores tipográficos en su código y mejora la capacidad de mantenimiento.

Todas **las constantes se deben recopilar en un solo paquete utilizado como biblioteca**. Si estas constantes también deberían usarse en SQL, es una buena práctica escribir una función de paquete determinista para cada constante.

```sql
CREATE OR REPLACE PACKAGE constants_up IS
   co_president CONSTANT employees.job_id%TYPE := 'AD_PRES';
END constants_up;
/

DECLARE
   l_job employees.job_id%TYPE;
BEGIN
   SELECT e.job_id
     INTO l_job
     FROM employees e
    WHERE e.manager_id IS NULL;

   IF l_job = constants_up.co_president THEN
      NULL;
   END IF;
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      NULL; -- handle_no_data_found;
   WHEN TOO_MANY_ROWS THEN
      NULL; -- handle_too_many_rows;
END;
/
```

### G-1060: Evite almacenar ROWID o UROWID en tablas de base de datos

Es una práctica extremadamente peligrosa almacenar ROWIDs en una tabla, a excepción de algunos escenarios muy limitados de duración de tiempo de ejecución. Cualquier reorganización de tabla implícita manualmente explícita o generada por el sistema reasignará el ROWID de la fila y romperá la consistencia de los datos.

En lugar de usar ROWID para una referencia posterior a la fila original, uno debe usar la(s) columna(s) de clave primaria.

### G-1070: Evitar anidar bloques de comentarios

Tener un final de comentario dentro de un comentario de bloque terminará ese comentario de bloque. Esto no solo influye en su código sino que también es muy difícil de leer.

## Variables y Tipos

Sin Comentar

## Uso General

### G-2110: Trate de usar declaraciones ancladas para variables, constantes y tipos

Si se cambia el tamaño de la columna de base de datos last_name en la tabla Employees de VARCHAR2(20) a VARCHAR2(30) se producirá un error en el código siempre que se lea de la tabla un valor mayor que el tamaño codificado en formato duro. Esto se puede evitar utilizando declaraciones ancladas.

```sql
-- BAD
   l_last_name  VARCHAR2(20 CHAR);
-- :thumbsup:
   l_last_name  employees.last_name%TYPE;
```

### G-2120: Intente tener una sola ubicación para definir tus tipos

Único punto de cambio al cambiar el tipo de datos. No es necesario discutir dónde definir tipos o dónde buscar definiciones existentes.

Una única ubicación podría ser **un paquete de especificación de tipo o la base de datos** (tipos definidos por la base de datos).

```sql
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);
END types_up;
/

CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_proc IS
      l_note types_up.big_string_type;
   BEGIN
      l_note := some_function();
   END my_proc;
END my_package;
/
```

### G-2130: Trate de usar subtipos para construcciones usadas a menudo en su código

Único punto de cambio al cambiar el tipo de datos. Su código será más fácil de leer, ya que el uso de una variable/ constante puede derivarse de su definición.

Ejemplos de posibles definiciones de subtipo

|Tipo |Uso  |
|-----|-----|
|ora_name_type| Objeto correspondiente a los convenios de denominación de ORACLE (tabla, variable, columna, paquete, etc.).|
|max_vc2_type | Variable de cadena con tamaño máximo VARCHAR2.|
|array_index_type | El mejor tipo de datos de ajuste para la navegación de matriz.
|id_type| Tipo de datos utilizado para todas las columnas de clave primaria (id).

#### Ejemplo Subtipos

```sql
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);
END types_up;
/

CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_proc IS
      l_note types_up.big_string_type;
   BEGIN
      l_note := some_function();
   END my_proc;
END my_package;
/
```

### G-2140: Nunca inicializar variables con NULL

Las variables se inicializan a NULL de forma predeterminada.

### G-2150: Evite las comparaciones con el valor NULL, considere usar IS [NOT] NULL

El valor NULL puede causar confusión tanto desde el punto de vista de la revisión del código como de la ejecución del código. Siempre debe usar la sintaxis IS NULL o IS NOT NULL cuando necesite verificar si un valor es o no es NULL.

```sql
-- BAD
DECLARE
   l_value INTEGER;
BEGIN
   IF l_value = NULL THEN
      NULL;
   END IF;
END;
/
-- GOOD
DECLARE
   l_value INTEGER;
BEGIN
   IF l_value IS NULL THEN
      NULL;
   END IF;
END;
/
```

### G-2160: Evite inicializar variables usando funciones en la sección de declaración

Si su inicialización falla, no podrá manejar el error en su bloque de excepciones.

```sql
-- BAD
DECLARE
   co_department_id CONSTANT INTEGER := 100;
   l_department_name departments.department_name%TYPE :=
      department_api.name_by_id(in_id => co_department_id);
BEGIN
   sys.dbms_output.put_line(l_department_name);
END;
/
-- GOOD
DECLARE
   co_department_id  CONSTANT INTEGER := 100;
   co_unkown_name    CONSTANT departments.department_name%TYPE := 'unknown';
   l_department_name departments.department_name%TYPE;
BEGIN
   <<init>>
   BEGIN
      l_department_name := department_api.name_by_id(in_id => co_department_id);
   EXCEPTION
      WHEN value_error THEN
         l_department_name := co_unkown_name;
   END init;

   sys.dbms_output.put_line(l_department_name);
END;
/
```

### G-2170: Nunca sobrecargar las variables

La legibilidad de su código será mayor cuando no sobrecargue las variables.

```sql
-- BAD
BEGIN
   <<main>>
   DECLARE
      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';
      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';
      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';
      l_variable user_objects.object_name%TYPE := co_main;
   BEGIN
      <<sub>>
      DECLARE
         l_variable user_objects.object_name%TYPE := co_sub;
      BEGIN
         sys.dbms_output.put_line(l_variable || co_sep || main.l_variable);
      END sub;
   END main;
END;
/
-- GOOD
BEGIN
   <<main>>
   DECLARE
      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';
      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';
      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';
      l_main_variable user_objects.object_name%TYPE := co_main;
   BEGIN
      <<sub>>
      DECLARE
         l_sub_variable user_objects.object_name%TYPE := co_sub;
      BEGIN
         sys.dbms_output.put_line(l_sub_variable || co_sep || l_main_variable);
      END sub;
   END main;
END;
/
```

### G-2180: Nunca use identificadores entre comillas

Los identificadores entre comillas hacen que su código sea difícil de leer y mantener.

### G-2185: Evite utilizar nombres demasiado cortos para identificadores declarados explícita o implícitamente

Usted debe asegurarse de que el nombre que ha elegido bien define su propósito y uso. Mientras que usted puede ahorrar algunas pulsaciones tecleando nombres muy cortos, el código resultante es obscuro y duro para cualquier persona además del autor para entender.

```sql
-- BAD
DECLARE
   i INTEGER;
   c CONSTANT INTEGER := 1;
   e EXCEPTION;
BEGIN
   i := c;
EXCEPTION
   WHEN e THEN
      NULL;
END;
/
-- GOOD
DECLARE
   l_sal_comm     INTEGER;
   co_my_constant CONSTANT INTEGER := 1;
   e_my_exception EXCEPTION;
BEGIN
   l_sal_comm := co_my_constant;
EXCEPTION
   WHEN e_my_exception THEN
      NULL;
END;
/
```

### G-2190: Evite utilizar ROWID o UROWID

Tenga cuidado con el uso de tipos de datos específicos de Oracle como ROWID y UROWID. Pueden ofrecer una leve mejora en el rendimiento con respecto a otros medios de identificar una sola fila (clave principal o valor de índice único), pero eso no está garantizado de ninguna manera.

El uso de ROWID o UROWID significa que su declaración SQL no será portable a otras bases de datos SQL. Muchos desarrolladores también no están familiarizados con estos tipos de datos, que pueden hacer el código más difícil de mantener.

## Tipos Numéricos

### G-2210: Evite declarar NUMBER variables, constantes o subtipos sin precisión

Si no especifica la precisión, el NÚMERO está predeterminado a 38 o el máximo admitido por su sistema, el que sea menor. Es posible que necesite toda esta precisión, pero si sabe que no, debe especificar lo que se adapte a sus necesidades.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_small_increase CONSTANT NUMBER := 0.1;

   FUNCTION small_increase RETURN NUMBER IS
   BEGIN
      RETURN co_small_increase;
   END small_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_small_increase CONSTANT NUMBER(5,1) := 0.1;

   FUNCTION small_increase RETURN NUMBER IS
   BEGIN
      RETURN co_small_increase;
   END small_increase;
END constants_up;
/
```

### G-2220: Trate de usar PLS_INTEGER en lugar de NUMBER para operaciones aritméticas con valores enteros

PLS_INTEGER con una longitud de -2,147,483,648 a 2,147,483,647, en un sistema de 32 bits.
Hay muchas razones para usar PLS_INTEGER en lugar de NUMBER:

- PLS_INTEGER usa menos memoria
- PLS_INTEGER utiliza aritmética de máquina, que es hasta tres veces más rápida que la aritmética de biblioteca, que es utilizada por NÚMERO.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT NUMBER(5,0) := 1;

   FUNCTION big_increase RETURN NUMBER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT PLS_INTEGER := 1;

   FUNCTION big_increase RETURN PLS_INTEGER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
```

### G-2230: Try to use SIMPLE_INTEGER datatype when appropriate

Trate de usar el tipo de datos SIMPLE_INTEGER cuando sea apropiado para ORACLE 11g o posterior.

SIMPLE_INTEGER no verifica el desbordamiento numérico, lo que resulta en un mejor rendimiento en comparación con los otros tipos de datos numéricos.

Con ORACLE 11g, se ha introducido el nuevo tipo de datos SIMPLE_INTEGER. Es un sub-tipo de PLS_INTEGER y cubre la misma gama.

La diferencia básica es que SIMPLE_INTEGER siempre no es NULL. Cuando el valor de la variable declarada nunca va a ser null, entonces puede declararlo como SIMPLE_INTEGER.

Otra diferencia importante es que nunca se enfrentará a un desbordamiento numérico utilizando SIMPLE_INTEGER como este tipo de datos envuelve alrededor sin dar ningún error.

El tipo de datos SIMPLE_INTEGER proporciona un mayor rendimiento en PLS_INTEGER cuando el código se compila en modo nativo, ya que las operaciones aritméticas en el tipo SIMPLE_INTEGER se realizan directamente a nivel de hardware.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT NUMBER(5,0) := 1;

   FUNCTION big_increase RETURN NUMBER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT SIMPLE_INTEGER := 1;

   FUNCTION big_increase RETURN SIMPLE_INTEGER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
```

## Tipos Carácter

### G-2310: Avoid using CHAR data type

Evite utilizar el tipo de datos CHAR. CHAR es un tipo de datos de longitud fija, que solo debe usarse cuando sea apropiado. Las columnas/variables CHAR siempre se llenan en sus longitudes especificadas; Esto puede llevar a efectos secundarios no deseados y resultados no deseados.

```sql
-- BAD
CREATE OR REPLACE PACKAGE types_up
IS
   SUBTYPE description_type IS CHAR(200);
END types_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE types_up
IS
   SUBTYPE description_type IS VARCHAR2(200 CHAR);
END types_up;
/
```

### G-2320: Evite usar el tipo de datos VARCHAR

No utilice el tipo de datos VARCHAR. En su lugar, utilice el tipo de datos VARCHAR2. Aunque el tipo de datos VARCHAR es actualmente sinónimo de VARCHAR2, el tipo de datos VARCHAR está programado para ser redefinido como un tipo de datos separado utilizado para cadenas de caracteres de longitud variable en comparación con diferentes semánticas de comparación.

### G-2330: Nunca use cadenas de longitud cero para sustituir NULL

Hoy en día, las cadenas de longitud cero y NULL actualmente se manejan de forma idéntica por ORACLE. No hay garantía de que este sea el caso en futuras versiones, por lo tanto, si quiere decir NULL use NULL.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_null_string CONSTANT VARCHAR2(1) := '';

   FUNCTION null_string RETURN VARCHAR2 IS
   BEGIN
       RETURN co_null_string;
   END null_string;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS

   FUNCTION empty_string RETURN VARCHAR2 IS
   BEGIN
       RETURN NULL;
   END empty_string;
END constants_up;
/
```

### G-2340: Siempre defina sus variables VARCHAR2 usando CHAR SEMANTIC (si no está definido anclado)

Los cambios en el NLS_LENGTH_SEMANTIC solo serán recogidos por su código después de una recompilación.

En un entorno multibyte, una definición VARCHAR2(10) puede no contener necesariamente 10 caracteres, cuando los caracteres multibyte forman parte del valor que debe almacenarse, a menos que la definición se haya realizado con el carácter semántico.

```sql
-- BAD
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE description_type IS VARCHAR2(200);
END types_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE description_type IS VARCHAR2(200 CHAR);
END types_up;
/
```

## Tipos Booleanos

### G-2410: Trate de usar el tipo de datos booleano para valores con doble significado

El uso de TRUE y FALSE aclara que este es un valor booleano y hace que el código sea más fácil de leer.

```sql
-- BAD
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger   PLS_INTEGER;
BEGIN
   IF co_newFile < co_oldFile THEN
      l_bigger := constants_up.co_numeric_true;
   ELSE
      l_bigger := constants_up.co_numeric_false;
   END IF;
END;
/
-- BETTER
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger  BOOLEAN;
BEGIN
   IF co_newFile < co_oldFile THEN
      l_bigger := TRUE;
   ELSE
      l_bigger := FALSE;
   END IF;
END;
/
-- GOOD
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger  BOOLEAN;
BEGIN
   l_bigger := NVL(co_newFile < co_oldFile,FALSE);
END;
/
```

## Large Objetos

### G-2510: Evite utilizar los tipos de datos LONG y LONG RAW

ORACLE ha desaprobado los tipos de datos LONG y LONG RAW desde la versión 8i: el soporte podría suspenderse en futuras versiones de ORACLE.

Existen muchas restricciones para los tipos de datos LONG en comparación con los tipos de LOB.

```sql
-- BAD
CREATE OR REPLACE PACKAGE example_package IS
   g_long LONG;
   g_raw  LONG RAW;

   PROCEDURE do_something;
END example_package;
/

CREATE OR REPLACE PACKAGE BODY example_package IS
   PROCEDURE do_something IS
   BEGIN
      NULL;
   END do_something;
END example_package;
/
-- GOOD
CREATE OR REPLACE PACKAGE example_package IS
   PROCEDURE do_something;
END example_package;
/

CREATE OR REPLACE PACKAGE BODY example_package IS
   g_long CLOB;
   g_raw  BLOB;

   PROCEDURE do_something IS
   BEGIN
      NULL;
   END do_something;
END example_package;
/
```

## DML/SQL

## General (DML/SQL)

### G-3110: Siempre especifique las columnas de destino al codificar una instrucción de inserción

Las estructuras de datos a menudo cambian. Tener las columnas de destino en sus declaraciones de inserción dará lugar a un código resistente al cambio.

```sql
-- BAD
INSERT INTO departments
     VALUES (departments_seq.nextval
            ,'Support'
            ,100
            ,10);
-- GOOD
INSERT INTO departments (department_id
                        ,department_name
                        ,manager_id
                        ,location_id)
     VALUES (departments_seq.nextval
            ,'Support'
            ,100
            ,10);
```

### G-3120: Siempre use alias de tablas cuando su declaración SQL involucre más de una fuente

Es más legible para los humanos usar alias en lugar de escribir columnas sin información de tablas. Especialmente cuando se usan subconsultas, la omisión de alias de tablas puede terminar en un comportamiento y resultado inesperado.

```sql
-- BAD
SELECT last_name
      ,first_name
      ,department_name
  FROM      employees
       JOIN departments USING (department_id)
 WHERE EXTRACT(MONTH FROM hire_date) = EXTRACT(MONTH FROM SYSDATE);
-- BETTER
SELECT e.last_name
      ,e.first_name
      ,d.department_name
  FROM      employees   e
       JOIN departments d ON (e.department_id = d.department_id)
 WHERE EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);

-- GOOD
-- El uso de alias significativos mejora la legibilidad de su código.

SELECT emp.last_name
      ,emp.first_name
      ,dept.department_name
  FROM      employees   emp
       JOIN departments dept ON (emp.department_id = dept.department_id)
 WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);
```

### G-3130: Trate de usar la sintaxis de unión ANSI

La sintaxis de unión ANSI admite la unión externa completa. Otra ventaja de la sintaxis de unión ANSI es la separación de la condición de unión de los filtros de consulta.

```sql
-- BAD
SELECT e.employee_id
      ,e.last_name
      ,e.first_name
      ,d.department_name
  FROM employees e
      ,departments d
 WHERE e.department_id = d.department_id
   AND EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);
/
-- GOOD
SELECT emp.employee_id
      ,emp.last_name
      ,emp.first_name
      ,dept.department_name
  FROM      employees   emp
       JOIN departments dept ON dept.department_id = emp.department_id
 WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);
```

### G-3140: Trate de usar registros anclados como objetivos para sus cursores. ROWTYPE

El uso de registros anclados por el cursor como objetivos para los resultados de sus cursores permite la posibilidad de cambiar la estructura del cursor sin tener en cuenta la estructura del objetivo.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, first_name, last_name
        FROM employees;
   l_employee_id employees.employee_id%TYPE;
   l_first_name  employees.first_name%TYPE;
   l_last_name   employees.last_name%TYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;
   <<process_employees>>
   WHILE c_employees%FOUND
   LOOP
      -- do something with the data
      FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;
   END LOOP process_employees;
   CLOSE c_employees;
END;
/
-- GOOD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, first_name, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO r_employee;
   <<process_employees>>
   WHILE c_employees%FOUND
   LOOP
      -- do something with the data
      FETCH c_employees INTO r_employee;
   END LOOP process_employees;
   CLOSE c_employees;
END;
/
```

### G-3150: Trate de usar columnas de identidad para las claves sustitutas. *ORACLE 12c*

Una columna de identidad es una clave sustituta por diseño – no hay razón por la cual no debemos aprovechar esta implementación natural cuando las claves se generan en el nivel de base de datos. El uso de la columna de identidad (y, por tanto, la asignación de secuencias como valores predeterminados en las columnas) tiene una gran ventaja de rendimiento sobre una solución desencadenante.

```sql
-- BAD
CREATE TABLE locations (
   location_id        NUMBER(10)        NOT NULL
  ,location_name      VARCHAR2(60 CHAR) NOT NULL
  ,city               VARCHAR2(30 CHAR) NOT NULL
  ,CONSTRAINT locations_pk PRIMARY KEY (location_id)
  )
/

CREATE SEQUENCE location_seq START WITH 1 CACHE 20
/

CREATE OR REPLACE TRIGGER location_br_i
   BEFORE INSERT ON LOCATIONS
   FOR EACH ROW
BEGIN
   :new.location_id := location_seq.nextval;
END;
/
-- GOOD
CREATE TABLE locations (
   location_id        NUMBER(10)  GENERATED ALWAYS AS IDENTITY
  ,location_name      VARCHAR2(60 CHAR) NOT NULL
  ,city               VARCHAR2(30 CHAR) NOT NULL
  ,CONSTRAINT locations_pk PRIMARY KEY (location_id))
/
```

### G-3160: Avoid virtual columns to be visible. *ORACLE 12c*

Evita que las columnas virtuales sean visibles.

En contraste con las columnas visibles, las columnas invisibles no forman parte de un registro definido mediante la construcción% RowType. Esto es útil ya que una columna virtual no se puede rellenar mediante programación. Si su columna virtual es visible, tendrá que definir manualmente los tipos de registro utilizados en los paquetes de API para poder excluirlos de ser parte de la definición de registro.

Se puede acceder a las columnas invisibles añadiendo explícitamente a la lista de columnas en una instrucción SELECT.

```sql
-- BAD
ALTER TABLE employees
   ADD total_salary GENERATED ALWAYS AS (salary + NVL(commission_pct,0) * salary)
/

DECLARE
   r_employee employees%ROWTYPE;
   l_id employees.employee_id%TYPE := 107;
BEGIN
   r_employee := employee_api.employee_by_id(l_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   UPDATE employees
      SET ROW = r_employee
    WHERE employee_id = l_id;
END;
/

Error report -
ORA-54017: UPDATE operation disallowed ON virtual COLUMNS
ORA-06512: at line 9

-- GOOD
ALTER TABLE employees
   ADD total_salary INVISIBLE GENERATED ALWAYS AS
      (salary + NVL(commission_pct,0) * salary)
/

DECLARE
   r_employee employees%ROWTYPE;
   co_id CONSTANT employees.employee_id%TYPE := 107;
BEGIN
   r_employee := employee_api.employee_by_id(co_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   UPDATE employees
      SET ROW = r_employee
    WHERE employee_id = co_id;
END;
/
```

### G-3170: Siempre use las declaraciones DEFAULT ON NULL para asignar valores predeterminados a las columnas de la tabla si se niega a almacenar valores NULL. *ORACLE 12c*

Los valores predeterminados han sido anulables hasta Oracle 12C. Lo que significa que cualquier herramienta que envía NULL como un valor para una columna que tiene un valor predeterminado omite el valor predeterminado. Comenzando con Oracle 12C las definiciones predeterminadas pueden tener una definición en NULL además, que asignará el valor por defecto en caso de un valor null también.

```sql
-- BAD
CREATE TABLE null_test (
   test_case        NUMBER(2) NOT NULL
  ,column_defaulted VARCHAR2(10) DEFAULT 'Default')
/
INSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');
INSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);
INSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);

SELECT * FROM null_test;

TEST_CASE  COLUMN_DEF
---------  -----------
        1  Value
        2  Default
        3

-- GOOD
CREATE TABLE null_test (
   test_case        NUMBER(2) NOT NULL
  ,column_defaulted VARCHAR2(10) DEFAULT ON NULL 'Default')
/
INSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');
INSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);
INSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);

SELECT * FROM null_test;

 TEST_CASE COLUMN_DEF
---------- ----------
         1 Value
         2 Default
         3 Default
```

### G-3180: Siempre especifique nombres de columna en lugar de referencias posicionales en cláusulas ORDER BY

Si usted cambia su lista selecta después la orden cerca todavía funcionará pero orden sus filas diferentemente, al no cambiar el número posicional. Además, no es cómodo para los lectores del código, si tienen que contar las columnas en la lista de selección para saber la forma en que se ordena el resultado.

### G-3190: Evite el uso de NATURAL JOIN

Una combinación natural une tablas en columnas con nombres iguales. Esto puede caber cómodamente a primera vista, pero agregar columnas de registro a una tabla (changed_by, changed_date) resultará en condiciones de unión inapropiadas.

```sql
-- BAD
SELECT department_name
      ,last_name
      ,first_name
  FROM employees NATURAL JOIN departments
 ORDER BY department_name
         ,last_name;
DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William
Executive                      De Haan                   Lex
…

ALTER TABLE departments ADD modified_at DATE DEFAULT ON NULL SYSDATE;
ALTER TABLE employees ADD modified_at DATE DEFAULT ON NULL SYSDATE;

SELECT department_name
      ,last_name
      ,first_name
  FROM employees NATURAL JOIN departments
 ORDER BY department_name
         ,last_name;

No data found

-- GOOD
SELECT d.department_name
      ,e.last_name
      ,e.first_name
  FROM employees   e
  JOIN departments d ON (e.department_id = d.department_id)
 ORDER BY d.department_name
         ,e.last_name;

DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William
Executive                      De Haan                   Lex
…
```

## Operaciones BULK

### G-3210: Siempre use BULK OPERATIONS (BULK COLLECT, FORALL) cuando tenga que ejecutar una declaración DML más de 4 veces

Los cambios de contexto entre PL/SQL y SQL son extremadamente costosos. Las operaciones  BULK reducen el número de conmutadores al pasar una matriz al motor SQL, que se usa para ejecutar las declaraciones dadas repetidamente.

(Dependiendo del parámetro PLSQL_OPTIMIZE_LEVEL, el compilador PL/SQL realizará automáticamente una conversión a BULK COLLECT).

```sql
-- BAD
DECLARE
   t_employee_ids employee_api.t_employee_ids_type;
   co_increase CONSTANT employees.salary%type := 0.1;
   co_department_id CONSTANT departments.department_id%TYPE := 10;
BEGIN
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in => co_department_id
                     );
   <<process_employees>>
   FOR i IN 1..t_employee_ids.COUNT()
   LOOP
      UPDATE employees
         SET salary = salary + (salary * co_increase)
       WHERE employee_id = t_employee_ids(i);
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      CONSTANT employees.salary%type := 0.1;
   co_department_id CONSTANT departments.department_id%TYPE := 10;
BEGIN
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in => co_department_id
                     );
   <<process_employees>>
   FORALL i IN 1..t_employee_ids.COUNT()
      UPDATE employees
         SET salary = salary + (salary * co_increase)
       WHERE employee_id = t_employee_ids(i);
END;
/
```

## Estructuras de Control

## CURSOR

### G-4110: Siempre use %NOTFOUND en lugar de NOT ... %FOUND para verificar si un cursor devolvió datos

La legibilidad de su código será mayor cuando evite las oraciones negativas.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS
      SELECT last_name
            ,first_name
        FROM employees
       WHERE commission_pct IS NOT NULL;

   r_employee  c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN NOT c_employees%FOUND;
   END LOOP read_employees;

   CLOSE c_employees;
END;
/

-- GOOD
DECLARE
   CURSOR c_employees IS
      SELECT last_name
            ,first_name
        FROM employees
       WHERE commission_pct IS NOT NULL;

   r_employee  c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN c_employees%NOTFOUND;
   END LOOP read_employees;

   CLOSE c_employees;
END;
/
```

### G-4120: Evite usar %NOTFOUND directamente después del FETCH cuando trabaje con BULK OPERATIONS y la cláusula LIMIT

%NOTFOUND se establece en VERDADERO tan pronto como se ha leído el número de filas definidas por la cláusula LIMIT.

```sql
-- BAD
/*
La tabla de empleados tiene 107 filas. El ejemplo a continuación solo mostrará 100 filas ya que el atributo de cursor NOTFOUND se establece en verdadero tan pronto como el número de filas a ser definidas por la cláusula límite ya no se cumpla.
*/
DECLARE
   CURSOR c_employees IS
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      EXIT process_employees WHEN c_employees%NOTFOUND;

      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/

-- BETTER
/*
Este ejemplo mostrará las 107 filas pero ejecutará una búsqueda de más (12 en lugar de 11).

*/
DECLARE
   CURSOR c_employees IS
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      EXIT process_employees WHEN t_employees.COUNT() = 0;
      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/

-- GOOD
/*
Este ejemplo hace el truco (11 búsquedas solo para procesar todas las filas)
*/

DECLARE
   CURSOR c_employees IS
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
      EXIT process_employees WHEN t_employees.COUNT() <> co_bulk_size;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/
```

### G-4130: Cerrar siempre los cursores abiertos localmente

Los cursores que queden abiertos pueden consumir espacio de memoria adicional (es decir, SGA) dentro de la instancia de la base de datos, potencialmente en las agrupaciones SQL compartidas y privadas. Además, si no se cierran explícitamente los cursores, la sesión propietaria excederá su límite máximo de cursores abiertos (como se especifica en el parámetro de inicialización de la base de datos **OPEN_CURSORS**), lo que potencialmente resultará en el error de Oracle de "ORA-01000: Máximo número de cursores abiertos exedidos".

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)
      RETURN NUMBER IS
      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS
         SELECT sum(salary) AS sum_salary
           FROM employees
          WHERE department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   BEGIN
      OPEN c_department_salary(p_dept_id => in_dept_id);
      FETCH c_department_salary INTO r_department_salary;

      RETURN r_department_salary.sum_salary;
   END department_salary;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)
      RETURN NUMBER IS
      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS
         SELECT SUM(salary) AS sum_salary
           FROM employees
          WHERE department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   BEGIN
      OPEN c_department_salary(p_dept_id => in_dept_id);
      FETCH c_department_salary INTO r_department_salary;
      CLOSE c_department_salary;
      RETURN r_department_salary.sum_salary;
   END department_salary;
END employee_api;
/
```

### G-4140: Evite ejecutar cualquier declaración entre una operación de SQL y el uso de un atributo de cursor implícito

Oracle proporciona una variedad de atributos de cursor (como %FOUND y %ROWCOUNT) que se pueden usar para obtener información sobre el estado de un cursor, ya sea implícito o explícito.

Debe evitar insertar cualquier declaración entre el funcionamiento del cursor y el uso de un atributo contra ese cursor. La interposición de dicha instrucción puede afectar al valor devuelto por el atributo, lo que potencialmente corrompe la lógica del programa.

En el ejemplo siguiente, se inserta una llamada de procedimiento entre la instrucción DELETE y una comprobación del valor de SQL%ROWCOUNT, que devuelve el número de filas modificadas por la última instrucción SQL ejecutada en la sesión. Si este procedimiento incluye un COMMIT/ROLLBACK u otro cursor implícito, el valor de SQL%ROWCOUNT se verá afectado.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   co_one CONSTANT SIMPLE_INTEGER := 1;

   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS
   BEGIN
      NULL;
   END process_dept;

   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS
      l_dept_id      employees.department_id%TYPE;
   BEGIN
      DELETE FROM employees
       WHERE employee_id = in_employee_id
       RETURNING department_id INTO l_dept_id;

      process_dept(in_dept_id => l_dept_id);

      IF SQL%ROWCOUNT > co_one THEN
         -- too many rows deleted.
         ROLLBACK;
      END IF;
   END remove_employee;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   co_one CONSTANT SIMPLE_INTEGER := 1;

   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS
   BEGIN
      NULL;
   END process_dept;

   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS
      l_dept_id      employees.department_id%TYPE;
      l_deleted_emps SIMPLE_INTEGER;
   BEGIN
      DELETE FROM employees
       WHERE employee_id = in_employee_id
       RETURNING department_id INTO l_dept_id;

      l_deleted_emps := SQL%ROWCOUNT;

      process_dept(in_dept_id => l_dept_id);

      IF l_deleted_emps > co_one THEN
         -- too many rows deleted.
         ROLLBACK;
      END IF;
   END remove_employee;
END employee_api;
/
```

## CASE / IF / DECODE / NVL / NVL2 / COALESCE

### G-4210: Intente utilizar CASE en lugar de una instrucción IF con varias rutas de ELSIF

Las declaraciones IF que contienen múltiples ELSIF tienden a volverse complejas rápidamente.

### G-4220: Trate de usar CASE en lugar de DECODE

DECODE es una función específica de ORACLE difícil de entender y restringida a SQL solamente. La función CASE "más nueva" es mucho más común, tiene una mejor legibilidad y también se puede utilizar en PL/SQL.

```sql
-- BAD
SELECT DECODE(dummy, 'X', 1
                      , 'Y', 2
                      , 'Z', 3
                      , 0)
        FROM dual;

-- GOOD
    SELECT CASE dummy
          WHEN 'X' THEN 1
          WHEN 'Y' THEN 2
          WHEN 'Z' THEN 3
          ELSE 0
    END
  FROM dual;
```

### G-4230: Siempre use un COALESCE en lugar de un comando NVL, si el parámetro 2 de la función NVL es una llamada de función o una instrucción SELECT

La función NVL siempre evalúa ambos parámetros antes de decidir cuál utilizar. Esto puede ser perjudicial si el parámetro 2 es una llamada de función o una instrucción SELECT, ya que se ejecutará independientemente de si el parámetro 1 contiene un valor
NULL o no.

La función COALESCE no tiene este inconveniente.

```sql
-- BAD
SELECT NVL(dummy, my_package.expensive_null(value_in => dummy))
  FROM dual;

-- GOOD
SELECT COALESCE(dummy, my_package.expensive_null(value_in => dummy))
  FROM dual;
```

### G-4240: Siempre use un CASE en lugar de un comando NVL2 si el parámetro 2 o 3 de NVL2 es una llamada de función o una instrucción SELECT

La función NVL2 siempre evalúa todos los parámetros antes de decidir cuál utilizar. Esto puede ser perjudicial, si el parámetro 2 o 3 es una llamada de función o una instrucción SELECT, ya que se ejecutarán independientemente de si el parámetro 1 contiene un valor NULL o no.

```sql
-- BAD
SELECT NVL2(dummy, my_package.expensive_nn(value_in => dummy),
                   my_package.expensive_null(value_in => dummy))
  FROM dual;

-- GOOD
SELECT CASE
          WHEN dummy IS NULL THEN
             my_package.expensive_null(value_in => dummy)
          ELSE
             my_package.expensive_nn(value_in => dummy)
       END
FROM dual;
```

## Control de flujo

### G-4310: Nunca use declaraciones GOTO en su código

El código que contiene GOTOs es difícil de formatear. La sangría se debe usar para mostrar la estructura lógica y los GOTOs tienen un efecto en la estructura lógica. Tratar de usar la sangría para mostrar la estructura lógica de un goto, sin embargo, es difícil o imposible.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS
      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';
      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
      co_errno       CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
      l_isdigit      BOOLEAN     := FALSE;
      l_len_pw       PLS_INTEGER;
      l_len_array    PLS_INTEGER;
   BEGIN
      l_len_pw    := LENGTH(in_password);
      l_len_array := LENGTH(co_digitarray);

      <<check_digit>>
      FOR i IN co_lower_bound .. l_len_array
      LOOP
         <<check_pw_char>>
         FOR j IN co_lower_bound .. l_len_pw
         LOOP
            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN
               l_isdigit := TRUE;
               GOTO check_other_things;
            END IF;
         END LOOP check_pw_char;
      END LOOP check_digit;

      <<check_other_things>>
      NULL;

      IF NOT l_isdigit THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/

-- BETTER
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS
      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';
      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
      co_errno       CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
      l_isdigit      BOOLEAN     := FALSE;
      l_len_pw       PLS_INTEGER;
      l_len_array    PLS_INTEGER;
   BEGIN
      l_len_pw    := LENGTH(in_password);
      l_len_array := LENGTH(co_digitarray);

      <<check_digit>>
      FOR i IN co_lower_bound .. l_len_array
      LOOP
         <<check_pw_char>>
         FOR j IN co_lower_bound .. l_len_pw
         LOOP
            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN
               l_isdigit := TRUE;
               EXIT check_digit; -- early exit condition
            END IF;
         END LOOP check_pw_char;
      END LOOP check_digit;

      <<check_other_things>>
      NULL;

      IF NOT l_isdigit THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS
      co_digitpattern CONSTANT STRING(10 CHAR)   := '\d';
      co_errno        CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg       CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
   BEGIN
      IF NOT REGEXP_LIKE(in_password, co_digitpattern)
      THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/
```

### G-4320: Etiqueta siempre tus bucles

```sql
-- BAD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   WHILE (i <= co_max_value)
   LOOP
      i := i + co_increment;
   END LOOP;

   LOOP
      EXIT;
   END LOOP;

   FOR i IN co_min_value..co_max_value
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP;

   FOR r_employee IN (SELECT last_name FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP;
END;
/

-- GOOD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value)
   LOOP
      i := i + co_increment;
   END LOOP while_loop;

   <<basic_loop>>
   LOOP
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP process_employees;
END;
/
```

### G-4330: Utilice siempre un bucle CURSOR FOR para procesar los resultados completos del cursor a menos que esté utilizando operaciones masivas

Es más fácil para el lector ver que se procesa el conjunto de datos completo. El uso de SQL para definir los datos a procesar es más fácil de mantener y, por lo general, más rápido que usar el procesamiento condicional dentro del bucle.

Dado que una instrucción EXIT es similar a una instrucción GOTO, debe evitarse siempre que sea posible.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN c_employees%NOTFOUND;
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP read_employees;

   CLOSE c_employees;
END;
/

-- GOOD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
BEGIN
   <<read_employees>>
   FOR r_employee IN c_employees
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP read_employees;
END;
/
```

### G-4340: Siempre use un bucle NUMERIC FOR para procesar una matriz densa

Es más fácil para el lector ver que se procesa la matriz completa.

Dado que una instrucción EXIT es similar a una instrucción GOTO, debe evitarse siempre que sea posible.

```sql
-- BAD
DECLARE
   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_himuro     CONSTANT INTEGER := 118;
   co_livingston CONSTANT INTEGER := 177;
   co_min_value  CONSTANT SIMPLE_INTEGER := 1;
   co_increment  CONSTANT SIMPLE_INTEGER := 1;
   i PLS_INTEGER;
BEGIN
   t_employees := t_employee_type(co_himuro, co_livingston);
   i           := co_min_value;

   <<process_employees>>
   LOOP
      EXIT process_employees WHEN i > t_employees.COUNT();
      sys.dbms_output.put_line(t_employees(i));
      i := i + co_increment;
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_himuro     CONSTANT INTEGER := 118;
   co_livingston CONSTANT INTEGER := 177;
BEGIN
   t_employees := t_employee_type(co_himuro, co_livingston);

   <<process_employees>>
   FOR i IN 1..t_employees.COUNT()
   LOOP
     sys.dbms_output.put_line(t_employees(i));
   END LOOP process_employees;
END;
/
```

### G-4350: Siempre use 1 como inferior y COUNT() como límite superior cuando realice un bucle a través de una matriz densa

Al hacerlo, no se generará un VALUE_ERROR si la matriz a través de la cual está circulando está vacía. Si desea utilizar FIRST() ... LAST(), debe verificar la matriz en busca de vacío de antemano para evitar el aumento de VALUE_ERROR.

```sql
-- BAD
DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   <<process_employees>>
   FOR i IN t_employees.FIRST()..t_employees.LAST()
   LOOP
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   END LOOP process_employees;
END;
/
-- BETTER
/*
Lance un error de colección unificada si t_employees no está inicializado.
*/

DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   <<process_employees>>
   FOR i IN 1..t_employees.COUNT()
   LOOP
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   END LOOP process_employees;
END;
/

-- GOOD
/*
No genera un error ni comprueba si la matriz está vacía. t_employees.COUNT() siempre devuelve un NÚMERO (a menos que la matriz no esté inicializada). Si la matriz está vacía, COUNT() devuelve 0 y, por lo tanto, el bucle no se ingresará.
*/

DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   IF t_employees IS NOT NULL THEN
      <<process_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i)); -- some processing
      END LOOP process_employees;
   END IF;
END;
/
```

### G-4360: Siempre use un bucle WHILE para procesar una matriz suelta

Cuando se procesa una matriz suelta utilizando un bucle numérico para que tengamos que comprobar con todas las iteraciones si el elemento existe para evitar una excepción NO_DATA_FOUND.

Además, el número de iteraciones no está impulsado por el número de elementos de la matriz, sino por el número del elemento más bajo o más alto. Cuantas más saltos tengamos, más iteraciones superfluas se realizarán.

```sql
-- BAD
DECLARE -- raises no_data_found when processing 2nd record
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_rogers      CONSTANT INTEGER := 134;
   co_matos       CONSTANT INTEGER := 143;
   co_mcewen      CONSTANT INTEGER := 158;
   co_index_matos CONSTANT INTEGER := 2;
BEGIN
   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);
   t_employees.DELETE(co_index_matos);

   IF t_employees IS NOT NULL THEN
      <<process_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i));
      END LOOP process_employees;
   END IF;
END;
/

-- GOOD
DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_rogers      CONSTANT INTEGER := 134;
   co_matos       CONSTANT INTEGER := 143;
   co_mcewen      CONSTANT INTEGER := 158;
   co_index_matos CONSTANT INTEGER := 2;
   l_index        PLS_INTEGER;
BEGIN
   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);
   t_employees.DELETE(co_index_matos);

   l_index := t_employees.FIRST();

   <<process_employees>>
   WHILE l_index IS NOT NULL
   LOOP
      sys.dbms_output.put_line(t_employees(l_index));
      l_index := t_employees.NEXT(l_index);
   END LOOP process_employees;
END;
/
```

### G-4370: Evite utilizar EXIT para detener el procesamiento del bucle a menos que esté en un bucle básico

Un numérico para bucle así como un bucle while y un cursor para bucle tienen límites de bucle definidos. Si no puede salir de su bucle utilizando esos límites de bucle, entonces un bucle básico es el bucle correcto para elegir.

```sql
-- BAD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value)
   LOOP
      i := i + co_increment;
      EXIT while_loop WHEN i > co_max_value;
   END LOOP while_loop;

   <<basic_loop>>
   LOOP
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP
      NULL;
      EXIT for_loop WHEN i = co_max_value;
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
      NULL; -- some processing
      EXIT process_employees;
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value)
   LOOP
      i := i + co_increment;
   END LOOP while_loop;

   <<basic_loop>>
   LOOP
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name); -- some processing
   END LOOP process_employees;
END;
/
```

### G-4375: Utilice siempre EXIT WHEN en lugar de una instrucción IF para salir de un bucle

Si necesita usar una instrucción EXIT, use su semántica completa para que el código sea más fácil de entender y mantener. Simplemente no hay necesidad de una declaración IF adicional.

```sql
-- BAD
DECLARE
   co_first_year CONSTANT PLS_INTEGER := 1900;
BEGIN
   <<process_employees>>
   LOOP
      my_package.some_processing();

      IF EXTRACT(year FROM SYSDATE) > co_first_year THEN
         EXIT process_employees;
      END IF;

      my_package.some_further_processing();
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   co_first_year CONSTANT PLS_INTEGER := 1900;
BEGIN
   <<process_employees>>
   LOOP
      my_package.some_processing();

      EXIT process_employees WHEN EXTRACT(YEAR FROM SYSDATE) > co_first_year;

      my_package.some_further_processing();
   END LOOP process_employees;
END;
/
```

### G-4380 Trate de etiquetar sus declaraciones EXIT WHEN

Es una buena alternativa para los comentarios, especialmente para los bucles anidados para nombrar el bucle para salir.

```sql
-- BAD
DECLARE
   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;
   co_increment  CONSTANT SIMPLE_INTEGER           := 1;
   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;
   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp PLS_INTEGER;
   l_innerlp PLS_INTEGER;
BEGIN
   l_outerlp := co_init_loop;
   <<outerloop>>
   LOOP
      l_innerlp := co_init_loop;
      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;
      <<innerloop>>
      LOOP
         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text || l_outerlp ||
                                  co_inner_text || l_innerlp);

         EXIT WHEN l_innerlp = co_exit_value;
      END LOOP innerloop;

      EXIT WHEN l_innerlp = co_exit_value;
   END LOOP outerloop;
END;
/

-- GOOD
DECLARE
   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;
   co_increment  CONSTANT SIMPLE_INTEGER           := 1;
   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;
   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp PLS_INTEGER;
   l_innerlp PLS_INTEGER;
BEGIN
   l_outerlp := co_init_loop;
   <<outerloop>>
   LOOP
      l_innerlp := co_init_loop;
      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;
      <<innerloop>>
      LOOP
         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text || l_outerlp ||
                                  co_inner_text || l_innerlp);

         EXIT outerloop WHEN l_innerlp = co_exit_value;
      END LOOP innerloop;
   END LOOP outerloop;
END;
/
```

### G-4385: Nunca utilice un cursor para el bucle para comprobar si un cursor devuelve datos

Puede procesar más datos de los necesarios, lo que conduce a un mal rendimiento.

```sql
-- BAD
DECLARE
   l_employee_found BOOLEAN := FALSE;
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
BEGIN
   <<check_employees>>
   FOR r_employee IN c_employees
   LOOP
      l_employee_found := TRUE;
   END LOOP check_employees;
END;
/

-- GOOD
DECLARE
   l_employee_found BOOLEAN := FALSE;
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO r_employee;
   l_employee_found := c_employees%FOUND;
   CLOSE c_employees;
END;
/
```

### G-4390: Evite el uso de índices de bucles FOR sin referencia

Si el índice de bucle se usa para cualquier cosa que no sea el control de tráfico dentro del bucle, este es uno de los indicadores de que un bucle FOR numérico se está utilizando incorrectamente. El cuerpo real de las instrucciones ejecutables ignora completamente el índice de bucle. Cuando ese es el caso, es muy probable que no necesite el bucle en absoluto.

```sql
-- BAD
DECLARE
   l_row   PLS_INTEGER;
   l_value PLS_INTEGER;
   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;
   co_row_incr    CONSTANT SIMPLE_INTEGER           := 1;
   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;
   co_delimiter   CONSTANT types_up.short_text_type := ' ';
   co_first_value CONSTANT SIMPLE_INTEGER           := 100;
BEGIN
   l_row := co_lower_bound;
   l_value := co_first_value;
   <<for_loop>>
   FOR i IN co_lower_bound .. co_upper_bound
   LOOP
      sys.dbms_output.put_line(l_row || co_delimiter || l_value);
      l_row   := l_row + co_row_incr;
      l_value := l_value + co_value_incr;
   END LOOP for_loop;
END;
/

-- GOOD
DECLARE
   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;
   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;
   co_delimiter   CONSTANT types_up.short_text_type := ' ';
   co_first_value CONSTANT SIMPLE_INTEGER           := 100;
BEGIN
   <<for_loop>>
   FOR i IN co_lower_bound .. co_upper_bound
   LOOP
      sys.dbms_output.put_line(i || co_delimiter ||
                               to_char(co_first_value + i * co_value_incr));
   END LOOP for_loop;
END;
/
```

### G-4395: Evite los valores de límite superior o inferior codificados mediante el uso de bucles FOR

Su declaración LOOP utiliza un valor codificado para sus límites superior o inferior. Esto crea un "enlace débil" en su programa porque asume que este valor nunca cambiará. Una práctica mejor es crear una constante (o función) con nombre y hacer referencia a este elemento con nombre en lugar del valor codificado.

```sql
-- BAD
BEGIN
   <<for_loop>>
   FOR i IN 1..5
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/

-- GOOD
DECLARE
   co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER := 5;
BEGIN
   <<for_loop>>
   FOR i IN co_lower_bound..co_upper_bound
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/
```

## Manejo de excepciones

### G-5010: Trate de usar un framework de log/error para su aplicación

Tener un framework para generar/manejar/registrar sus errores le permite evitar fácilmente los números de error duplicados de la aplicación y tener diferentes mensajes de error para el mismo tipo de error. Debería incluir:

- Registro/Logging (diferentes canales como tabla, correo, archivo, etc. Si es necesario)
- Error al elevar/raise
- Soporte multilenguaje si es necesario
- Traducir mensajes de error de ORACLE a un texto de error fácil de usar
- Repositorio de errores

```sql
-- BAD
BEGIN
   sys.dbms_output.put_line('START');
   -- some processing
   sys.dbms_output.put_line('END');
END;
/

-- GOOD

DECLARE
  -- see https://github.com/OraOpenSource/Logger
  l_scope logger_logs.scope%type := 'DEMO';
BEGIN
  logger.log('START', l_scope);
  -- some processing
  logger.log('END', l_scope);
END;
/

-- Para habilitar el registro para todo el esquema
exec logger.set_level(logger.g_debug);
-- Para deshabilitar el registro:
exec logger.set_level(logger.g_off);
-- En lugar de deshabilitar todo el registro, establecer un nivel en "ERROR" podría ser un mejor enfoque:
exec logger.set_level(logger.g_error);
-- Ver el estado
exec logger.status

```

### G-5020: Nunca maneje excepciones sin nombre usando el número de error

Cuando se utilizan literales para los números de error, el lector necesita el manual de mensajes de error para no entender lo que está pasando. Comentar el código o usar constantes es una opción, pero es mejor usar excepciones con nombre, ya que garantiza un cierto nivel de coherencia que facilita el mantenimiento.

```sql
-- BAD
DECLARE
   co_no_data_found CONSTANT INTEGER := -1;
BEGIN
   my_package.some_processing(); -- some code which raises an exception
EXCEPTION
   WHEN TOO_MANY_ROWS THEN
      my_package.some_further_processing();
   WHEN OTHERS THEN
      IF SQLCODE = co_no_data_found THEN
         NULL;
      END IF;
END;
/

-- GOOD
BEGIN
   my_package.some_processing(); -- some code which raises an exception
EXCEPTION
   WHEN TOO_MANY_ROWS THEN
      my_package.some_further_processing();
   WHEN NO_DATA_FOUND THEN
      NULL; -- handle no_data_found
END;
/
```

### G-5030: Nunca asigne nombres de excepción predefinidos a las excepciones definidas por el usuario

Esto es propenso a errores porque su declaración local anula la declaración global. Si bien es técnicamente posible usar los mismos nombres, causa confusión para otras personas que necesitan leer y mantener este código. Además, deberá tener mucho cuidado de usar el prefijo ESTÁNDAR delante de cualquier referencia que necesite usar el comportamiento de excepción predeterminado de Oracle.

```sql
-- BAD
/*
Al usar el código a continuación, no podemos manejar la excepción no_data_found generada por la instrucción SELECT ya que hemos sobrescrito ese controlador de excepciones. Además, nuestro controlador de excepciones no tiene asignado el número de excepción, que se genera cuando la instrucción SELECT no encuentra ninguna fila.
*/
DECLARE
   l_dummy dual.dummy%TYPE;
   no_data_found    EXCEPTION;
   co_rownum        CONSTANT SIMPLE_INTEGER           := 0;
   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';
BEGIN
   SELECT dummy
     INTO l_dummy
     FROM dual
    WHERE ROWNUM = co_rownum;

   IF l_dummy IS NULL THEN
      RAISE no_data_found;
   END IF;
EXCEPTION
   WHEN no_data_found THEN
      sys.dbms_output.put_line(co_no_data_found);
END;
/

Error report -
ORA-01403: no data found
ORA-06512: at line 5
01403. 00000 -  "no data found"
*Cause:    No data was found from the objects.
*Action:   There was no data from the objects which may be due to end of fetch.


-- GOOD
DECLARE
   l_dummy dual.dummy%TYPE;
   empty_value      EXCEPTION;
   co_rownum        CONSTANT simple_integer           := 0;
   co_empty_value   CONSTANT types_up.short_text_type := 'empty_value';
   co_no_data_found CONSTANT types_up.short_text_type := 'no_data_found';
BEGIN
   SELECT dummy
     INTO l_dummy
     FROM dual
    WHERE rownum = co_rownum;

   IF l_dummy IS NULL THEN
      RAISE empty_value;
   END IF;
EXCEPTION
   WHEN empty_value THEN
      sys.dbms_output.put_line(co_empty_value);
   WHEN no_data_found THEN
      sys.dbms_output.put_line(co_no_data_found);
END;
/
```

### G-5040: Evite el uso de la cláusula WHEN OTHERS en una sección de excepción sin ningún otro manejador específico

No hay necesariamente ningún problema con el uso de WHEN OTHERS, pero puede hacer que "pierda" la información de error a menos que el código del controlador sea relativamente sofisticado.

En general, debe usar WHEN OTHERS para capturar todos y cada uno de los errores solo después de haber pensado en su sección ejecutable y haber decidido que no puede interceptar ninguna excepción específica.

Si sabe, por otro lado, que podría producirse una cierta excepción, incluya un controlador para ese error. Al declarar dos controladores de excepción diferentes, el código establece más claramente lo que esperamos que suceda y cómo queremos manejar los errores. Eso hace que sea más fácil de mantener y mejorar. También evitamos los números de error de codificación en los cheques contra SQLCODE.

```sql
-- BAD
BEGIN
   my_package.some_processing();
EXCEPTION
   WHEN OTHERS THEN
      my_package.some_further_processing();
END;
/

-- GOOD
BEGIN
   my_package.some_processing();
EXCEPTION
   WHEN DUP_VAL_ON_INDEX THEN
      my_package.some_further_processing();
END;
/
```

### G-5050: Evite el uso del procedimiento incorporado RAISE_APPLICATION_ERROR con un número de error 20nnn codificado o un mensaje codificado

Si no está muy organizado en la forma en que asigna, defina y use los números de error entre 20999 y 20000 (aquellos reservados por Oracle para su comunidad de usuarios), es muy fácil terminar con usos conflictivos.

Debe asignar estos números de error a las constantes nombradas y consolidar todas las definiciones dentro de un solo paquete.

Cuando llama a RAISE_APPLICATION_ERROR, debe hacer referencia a estos elementos con nombre y al texto del mensaje de error almacenado en una tabla.

Use su propio procedimiento de subida en lugar de llamadas explícitas a RAISE_APPLICATION_ERROR.

Si está generando una excepción de "sistema" como NO_DATA_FOUND, debe usar RAISE. Sin embargo, cuando desea generar un error específico de la aplicación, utiliza RAISE_APPLICATION_ERROR.

Si utiliza este último, debe proporcionar un número de error y un mensaje. Esto lleva a valores innecesarios y dañinos. Un enfoque más seguro es proporcionar un procedimiento de aumento predefinido que verifique automáticamente el número de error y determine la forma correcta de hacerlo.

```sql
-- BAD
BEGIN
   raise_application_error(-20501,'Invalid employee_id');
END;
/

-- GOOD
BEGIN
   err_up.raise(in_error => err.co_invalid_employee_id);
END;
/
```

### G-5060: Evitar excepciones no manejadas

Esta puede ser su intención, pero debe revisar el código para confirmar este comportamiento.

Si está generando un error en un programa, entonces está prediciendo claramente una situación en la que ocurrirá ese error. Debería considerar incluir un controlador en su código para errores predecibles, lo que permite un error grato e informativo. Después de todo, es mucho más difícil que un bloque adjunto esté al tanto de los diversos errores que puede cometer y, lo que es más importante, qué se debe hacer en respuesta al error.

La forma que toma este fallo no necesariamente tiene que ser una excepción. Al escribir funciones, puede decidir que, en el caso de ciertas excepciones, querrá devolver un valor como NULL, en lugar de permitir que una excepción se propague fuera de la función.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION name_by_id (in_id IN departments.department_id%TYPE)
      RETURN departments.department_name%TYPE IS
      l_department_name departments.department_name%TYPE;
   BEGIN
      SELECT department_name
        INTO l_department_name
        FROM departments
       WHERE department_id = in_id;

      RETURN l_department_name;
   END name_by_id;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION name_by_id (in_id IN departments.department_id%TYPE)
      RETURN departments.department_name%TYPE IS
      l_department_name departments.department_name%TYPE;
   BEGIN
      SELECT department_name
        INTO l_department_name
        FROM departments
       WHERE department_id = in_id;

      RETURN l_department_name;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN RETURN NULL;
      WHEN TOO_MANY_ROWS THEN RAISE;
   END name_by_id;
END department_api;
/
```

### G-5070: Evite usar excepciones predefinidas de Oracle

Ha planteado una excepción cuyo nombre fue definido por Oracle. Si bien es posible que tenga una buena razón para "usar" una de las excepciones predefinidas de Oracle, debe asegurarse de que no sería mejor declarar su propia excepción y plantearla en su lugar.

Si decide cambiar la excepción que está utilizando, debe aplicar la misma consideración a sus propias excepciones. Específicamente, no "reutilizar" las excepciones. Debe definir una excepción separada para cada condición de error, en lugar de usar la misma excepción para diferentes circunstancias.

Ser lo más específico posible con los errores planteados permitirá a los desarrolladores verificar y manejar los diferentes tipos de errores que puede producir el código.

```sql
-- BAD
BEGIN
   RAISE NO_DATA_FOUND;
END;
/

-- GOOD
DECLARE
   my_exception EXCEPTION;
BEGIN
   RAISE my_exception;
END;
/
```

## SQL Dinámico

### G-6010: Siempre usa una variable de carácter para ejecutar SQL dinámico

Tener la declaración ejecutada en una variable facilita la depuración de su código (por ejemplo, al registrar la declaración que falló).

```sql
-- BAD
DECLARE
   l_next_val employees.employee_id%TYPE;
BEGIN
   EXECUTE IMMEDIATE 'select employees_seq.nextval from dual' INTO l_next_val;
END;
/

-- GOOD
DECLARE
   l_next_val employees.employee_id%TYPE;
   co_sql CONSTANT types_up.big_string_type :=
       'select employees_seq.nextval from dual';
BEGIN
   EXECUTE IMMEDIATE co_sql INTO l_next_val;
END;
/
```

### G-6020: Intente usar los argumentos de enlace de salida en la cláusula RETURNING INTO de las declaraciones dinámicas de DML en lugar de la cláusula USING

Cuando una instrucción dinámica INSERT, UPDATE o DELETE tiene una cláusula RETURNING, los argumentos de enlace de salida pueden ir en la cláusula RETURNING INTO o en la cláusula USING.

Debe usar la cláusula RETURNING INTO para los valores devueltos por una operación DML. Reserve las variables de enlace OUT y IN OUT para los bloques dinámicos de PL/SQL que devuelven valores en las variables de PL/SQL.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE
                        ,in_increase_pct IN     types_up.percentage
                        ,out_new_salary     OUT employees.salary%TYPE)
   IS
      co_sql_stmt CONSTANT types_up.big_string_type := '
           UPDATE employees SET salary = salary + (salary / 100 * :1)
            WHERE employee_id = :2
        RETURNING salary INTO :3';
   BEGIN
     EXECUTE IMMEDIATE co_sql_stmt
           USING in_increase_pct, in_employee_id, OUT out_new_salary;
   END upd_salary;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   PROCEDURE upd_salary (in_employee_id  IN     employees.employee_id%TYPE
                        ,in_increase_pct IN     types_up.percentage
                        ,out_new_salary     OUT employees.salary%TYPE)
   IS
      co_sql_stmt CONSTANT types_up.big_string_type :=
          'UPDATE employees SET salary = salary + (salary / 100 * :1)
            WHERE employee_id = :2
        RETURNING salary INTO :3';
   BEGIN
     EXECUTE IMMEDIATE co_sql_stmt
           USING in_increase_pct, in_employee_id
           RETURNING INTO out_new_salary;
   END upd_salary;
END employee_api;
/
```

## Objetos Almacenados

### G-7110: Trate de usar la notación nombrada al llamar a las unidades del programa

La notación con nombre asegura que los cambios en la firma de la unidad del programa llamado no afecten su llamada.

Esto no es necesario para funciones estándar como (TO_CHAR, TO_DATE, NVL, ROUND, etc.), pero se debe seguir para cualquier otro objeto almacenado que tenga más de un parámetro.

```sql
-- BAD
DECLARE
   r_employee employees%rowtype;
   co_id CONSTANT employees.employee_id%type := 107;
BEGIN
   r_employee := employee_api.employee_by_id(co_id);
END;
/

-- GOOD
DECLARE
   r_employee employees%rowtype;
   co_id CONSTANT employees.employee_id%type := 107;
BEGIN
   r_employee := employee_api.employee_by_id(in_employee_id => co_id);
END;
/
```

### G-7120 Siempre agregue el nombre de la unidad del programa a su palabra clave final

Es una buena alternativa para que los comentarios indiquen el final de las unidades del programa, especialmente si son largas o están anidadas.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)
      RETURN employees%rowtype IS
      r_employee employees%rowtype;
   BEGIN
      SELECT *
        INTO r_employee
        FROM employees
       WHERE employee_id = in_employee_id;

      RETURN r_employee;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END;
END;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   FUNCTION employee_by_id (in_employee_id IN employees.employee_id%TYPE)
      RETURN employees%rowtype IS
      r_employee employees%rowtype;
   BEGIN
      SELECT *
        INTO r_employee
        FROM employees
       WHERE employee_id = in_employee_id;

      RETURN r_employee;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END employee_by_id;
END employee_api;
/
```

### G-7130: Siempre use parámetros o arrastre definiciones en lugar de hacer referencia a variables externas en una unidad de programa local

Los procedimientos y funciones locales ofrecen una excelente manera de evitar la redundancia de código y hacer que su código sea más legible (y, por lo tanto, más fácil de mantener).

Sin embargo, su programa local se refiere a una estructura de datos externa, es decir, una variable que se declara fuera del programa local. Por lo tanto, está actuando como una variable global dentro del programa.

Esta dependencia externa está oculta y puede causar problemas en el futuro. En su lugar, debe agregar un parámetro a la lista de parámetros de este programa y pasar el valor a través de la lista. Esta técnica hace que su programa sea más reutilizable y evita problemas de alcance, es decir, la unidad del programa está menos ligada a variables particulares en el programa. Además, la encapsulación de la unidad hace que el mantenimiento sea mucho más fácil y más barato.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS
   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS
      r_emp employees%rowtype;

      FUNCTION commission RETURN NUMBER IS
         l_commission employees.salary%TYPE := 0;
      BEGIN
         IF r_emp.commission_pct IS NOT NULL
         THEN
            l_commission := r_emp.salary * r_emp.commission_pct;
         END IF;

         RETURN l_commission;
      END commission;
   BEGIN
      SELECT *
        INTO r_emp
        FROM employees
       WHERE employee_id = in_employee_id;

      SYS.DBMS_OUTPUT.PUT_LINE(r_emp.salary + commission());
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
      WHEN TOO_MANY_ROWS THEN
         NULL;
   END calc_salary;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY EMPLOYEE_API IS
   PROCEDURE calc_salary (in_employee_id IN employees.employee_id%TYPE) IS
      r_emp employees%rowtype;

      FUNCTION commission (in_salary   IN employees.salary%TYPE
                          ,in_comm_pct IN employees.commission_pct%TYPE)
         RETURN NUMBER IS
         l_commission employees.salary%TYPE := 0;
      BEGIN
         IF in_comm_pct IS NOT NULL THEN
            l_commission := in_salary * in_comm_pct;
         END IF;

         RETURN l_commission;
      END commission;
   BEGIN
      SELECT *
        INTO r_emp
        FROM employees
       WHERE employee_id = in_employee_id;

      SYS.DBMS_OUTPUT.PUT_LINE(
         r_emp.salary + commission(in_salary   => r_emp.salary
                                  ,in_comm_pct => r_emp.commission_pct)
      );
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         NULL;
      WHEN TOO_MANY_ROWS THEN
         NULL;
   END calc_salary;
END employee_api;
/
```

### G-7140: Asegúrese siempre de que se hace referencia a los procedimientos o funciones definidos localmente

Esto puede ocurrir como resultado de cambios en el código a lo largo del tiempo, pero debe asegurarse de que esta situación no refleje un problema. Y debe eliminar la declaración para evitar errores de mantenimiento en el futuro.

Debe revisar sus programas y eliminar cualquier parte de su código que ya no se use. Este es un proceso relativamente sencillo para las variables y las constantes nombradas. Simplemente ejecute búsquedas para el nombre de una variable en el alcance de esa variable. Si encuentra que el único lugar donde aparece está en su declaración, elimine la declaración.

Nunca hay un mejor momento para revisar todos los pasos que tomó, y para comprender los motivos por los que los tomó, y luego inmediatamente después de completar su programa. Si espera, le resultará particularmente difícil recordar aquellas partes del programa que se necesitaron en un momento dado, pero que al final se volvieron innecesarias.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_procedure IS
      FUNCTION my_func RETURN NUMBER IS
         co_true CONSTANT INTEGER := 1;
      BEGIN
         RETURN co_true;
      END my_func;
   BEGIN
       NULL;
   END my_procedure;
END my_package;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_procedure IS
      FUNCTION my_func RETURN NUMBER IS
         co_true CONSTANT INTEGER := 1;
      BEGIN
         RETURN co_true;
      END my_func;
   BEGIN
       sys.dbms_output.put_line(my_func());
   END my_procedure;
END my_package;
/
```

### G-7150: Trate de eliminar los parámetros no utilizados

Debe revisar sus programas y eliminar cualquier partámetro que ya no se use.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE
                       ,in_manager_id    IN departments.manager_id%TYPE)
      RETURN departments.department_name%TYPE IS
      l_department_name departments.department_name%TYPE;
   BEGIN
      <<find_department>>
      BEGIN
         SELECT department_name
           INTO l_department_name
           FROM departments
          WHERE department_id = in_department_id;
      EXCEPTION
         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
            l_department_name := NULL;
      END find_department;

      RETURN l_department_name;
   END name_by_id;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)
      RETURN departments.department_name%TYPE IS
      l_department_name departments.department_name%TYPE;
   BEGIN
      <<find_department>>
      BEGIN
         SELECT department_name
           INTO l_department_name
           FROM departments
          WHERE department_id = in_department_id;
      EXCEPTION
         WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
            l_department_name := NULL;
      END find_department;

      RETURN l_department_name;
   END name_by_id;
END department_api;
/
```

## Paquetes

### G-7210: Trate de mantener sus paquetes pequeños. Incluya solo algunos procedimientos y funciones que se utilizan en el mismo contexto

El paquete completo se carga en la memoria cuando el paquete se llama la primera vez. Para optimizar el consumo de memoria y mantener el tiempo de carga, los paquetes pequeños deben mantenerse pequeños, pero incluya componentes que se utilizan juntos.

### G-7220: Siempre use la declaración hacia adelante/forward para funciones y procedimientos privados

Tener declaraciones de reenvío/forward le permite ordenar las funciones y procedimientos del paquete de una manera razonable.

```sql
-- BAD
CREATE OR REPLACE PACKAGE department_api IS
   PROCEDURE del (in_department_id IN departments.department_id%TYPE);
END department_api;
/

CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)
      RETURN BOOLEAN IS
      l_return PLS_INTEGER;
   BEGIN
      <<check_row_exists>>
      BEGIN
         SELECT 1
           INTO l_return
           FROM departments
          WHERE department_id = in_department_id;
      EXCEPTION
         WHEN no_data_found OR too_many_rows THEN
            l_return := 0;
      END check_row_exists;

      RETURN l_return = 1;
   END does_exist;

   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS
   BEGIN
      IF does_exist(in_department_id) THEN
        NULL;
      END IF;
   END del;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE department_api IS
   PROCEDURE del (in_department_id IN departments.department_id%TYPE);
END department_api;
/

CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)
      RETURN BOOLEAN;

   PROCEDURE del (in_department_id IN departments.department_id%TYPE) IS
   BEGIN
      IF does_exist(in_department_id) THEN
        NULL;
      END IF;
   END del;

   FUNCTION does_exist (in_department_id IN departments.department_id%TYPE)
      RETURN BOOLEAN IS
      l_return PLS_INTEGER;
   BEGIN
      <<check_row_exists>>
      BEGIN
         SELECT 1
           INTO l_return
           FROM departments
          WHERE department_id = in_department_id;
      EXCEPTION
         WHEN no_data_found OR too_many_rows THEN
            l_return := 0;
      END check_row_exists;

      RETURN l_return = 1;
   END does_exist;
END department_api;
/
```

### G-7230: Evitar declarar públicas las variables globales

Siempre debe declarar los datos a nivel de paquete dentro del cuerpo del paquete. Luego puede definir los métodos de "obtener y configurar" (funciones y procedimientos, respectivamente) en la especificación del paquete para proporcionar acceso controlado a esos datos. Al hacerlo, puede garantizar la integridad de los datos, puede cambiar la implementación de su estructura de datos y también hacer un seguimiento del acceso a esas estructuras de datos.

Las estructuras de datos (variables escalares, colecciones, cursores) declaradas en la especificación del paquete (que no se encuentran en ningún programa específico) pueden ser referenciadas directamente por cualquier programa que se ejecute en una sesión con derechos EXECUTE al paquete.

En su lugar, declare todos los datos de nivel de paquete en el cuerpo del paquete y proporcione los métodos  "get y set "-una función para obtener el valor y un procedimiento para establecer el valor-en la especificación del paquete. Los desarrolladores pueden acceder a los datos utilizando estos métodos, y seguirán automáticamente todas las reglas que se establezcan en la modificación de datos.

```sql
-- BAD
CREATE OR REPLACE PACKAGE employee_api AS
   co_min_increase CONSTANT types_up.sal_increase_type := 0.01;
   co_max_increase CONSTANT types_up.sal_increase_type := 0.5;
   g_salary_increase types_up.sal_increase_type := co_min_increase;

   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);
   FUNCTION salary_increase RETURN types_up.sal_increase_type;
END employee_api;
/

CREATE OR REPLACE PACKAGE BODY employee_api AS
   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS
   BEGIN
      g_salary_increase := GREATEST(LEAST(in_increase,co_max_increase)
                                   ,co_min_increase);
   END set_salary_increase;

   FUNCTION salary_increase RETURN types_up.sal_increase_type IS
   BEGIN
      RETURN g_salary_increase;
   END salary_increase;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE employee_api AS
   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type);
   FUNCTION salary_increase RETURN types_up.sal_increase_type;
END employee_api;
/

CREATE OR REPLACE PACKAGE BODY employee_api AS
   g_salary_increase types_up.sal_increase_type(4,2);

   PROCEDURE init;

   PROCEDURE set_salary_increase (in_increase IN types_up.sal_increase_type) IS
   BEGIN
      g_salary_increase := GREATEST(LEAST(in_increase
                                         ,constants_up.max_salary_increase())
                                   ,constants_up.min_salary_increase());
   END set_salary_increase;

   FUNCTION salary_increase RETURN types_up.sal_increase_type IS
   BEGIN
      RETURN g_salary_increase;
   END salary_increase;

   PROCEDURE init
   IS
   BEGIN
      g_salary_increase := constants_up.min_salary_increase();
   END init;
BEGIN
   init();
END employee_api;
/
```

### G-7240: Evite utilizar un parámetro IN OUT como IN o OUT solamente

Al mostrar el modo de los parámetros, usted ayuda al lector. Si no especifica un modo de parámetro, el modo predeterminado es IN.

Mostrar explícitamente la indicación de modo de todos los parámetros es una acción más asertiva que simplemente tomar el modo predeterminado. Cualquier persona que revisará el código más adelante será más seguro que usted pensó que el modo del parámetro era IN/OUT.

```sql
-- BAD
-- Bad
CREATE OR REPLACE PACKAGE BODY employee_up IS
   PROCEDURE rcv_emp (io_first_name     IN OUT employees.first_name%TYPE
                     ,io_last_name      IN OUT employees.last_name%TYPE
                     ,io_email          IN OUT employees.email%TYPE
                     ,io_phone_number   IN OUT employees.phone_number%TYPE
                     ,io_hire_date      IN OUT employees.hire_date%TYPE
                     ,io_job_id         IN OUT employees.job_id%TYPE
                     ,io_salary         IN OUT employees.salary%TYPE
                     ,io_commission_pct IN OUT employees.commission_pct%TYPE
                     ,io_manager_id     IN OUT employees.manager_id%TYPE
                     ,io_department_id  IN OUT employees.department_id%TYPE
                     ,in_wait                  INTEGER) IS
      l_status PLS_INTEGER;
      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';
      co_ok CONSTANT PLS_INTEGER := 1;
   BEGIN
      -- Receive next message and unpack for each column.
      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name
                                               ,timeout  => in_wait);
      IF l_status = co_ok THEN
         SYS.dbms_pipe.unpack_message (io_first_name);
         SYS.dbms_pipe.unpack_message (io_last_name);
         SYS.dbms_pipe.unpack_message (io_email);
         SYS.dbms_pipe.unpack_message (io_phone_number);
         SYS.dbms_pipe.unpack_message (io_hire_date);
         SYS.dbms_pipe.unpack_message (io_job_id);
         SYS.dbms_pipe.unpack_message (io_salary);
         SYS.dbms_pipe.unpack_message (io_commission_pct);
         SYS.dbms_pipe.unpack_message (io_manager_id);
         SYS.dbms_pipe.unpack_message (io_department_id);
      END IF;
   END rcv_emp;
END employee_up;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_up IS
   PROCEDURE rcv_emp (OUT_first_name     OUT employees.first_name%TYPE
                     ,OUT_last_name      OUT employees.last_name%TYPE
                     ,OUT_email          OUT employees.email%TYPE
                     ,OUT_phone_number   OUT employees.phone_number%TYPE
                     ,OUT_hire_date      OUT employees.hire_date%TYPE
                     ,OUT_job_id         OUT employees.job_id%TYPE
                     ,OUT_salary         OUT employees.salary%TYPE
                     ,OUT_commission_pct OUT employees.commission_pct%TYPE
                     ,OUT_manager_id     OUT employees.manager_id%TYPE
                     ,OUT_department_id  OUT employees.department_id%TYPE
                     ,in_wait            IN     INTEGER) IS
      l_status PLS_INTEGER;
      co_dflt_pipe_name CONSTANT STRING(30 CHAR) := 'MyPipe';
      co_ok CONSTANT PLS_INTEGER := 1;
   BEGIN
      -- Receive next message and unpack for each column.
      l_status := SYS.dbms_pipe.receive_message(pipename => co_dflt_pipe_name
                                               ,timeout  => in_wait);
      IF l_status = co_ok THEN
         SYS.dbms_pipe.unpack_message (out_first_name);
         SYS.dbms_pipe.unpack_message (out_last_name);
         SYS.dbms_pipe.unpack_message (out_email);
         SYS.dbms_pipe.unpack_message (out_phone_number);
         SYS.dbms_pipe.unpack_message (out_hire_date);
         SYS.dbms_pipe.unpack_message (out_job_id);
         SYS.dbms_pipe.unpack_message (out_salary);
         SYS.dbms_pipe.unpack_message (out_commission_pct);
         SYS.dbms_pipe.unpack_message (out_manager_id);
         SYS.dbms_pipe.unpack_message (out_department_id);
      END IF;
   END rcv_emp;
END employee_up;
/
```

## Procedimientos

### G-7310: Evite procedimientos independientes - ponga sus procedimientos en paquetes

Utilice paquetes para estructurar el código, combinar procedimientos y funciones que pertenezcan.

Los cuerpos del paquete pueden ser cambiados y compilados sin invalidar otros paquetes. Esta es una ventaja importante en comparación con los procedimientos y funciones independientes.

```sql
-- BAD
CREATE OR REPLACE PROCEDURE my_procedure IS
BEGIN
   NULL;
END my_procedure;
/

-- GOOD
CREATE OR REPLACE PACKAGE my_package IS
   PROCEDURE my_procedure;
END my_package;
/

CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_procedure IS
   BEGIN
      NULL;
   END my_procedure;
END my_package;
/
```

### 7320: Evite usar declaraciones RETURN en un PROCEDIMIENTO

El uso de la declaración RETURN es legal dentro de un procedimiento en PL/SQL, pero es muy similar a un GOTO, lo que significa que terminas con un código mal estructurado que es difícil de depurar y mantener.

UNA buena regla general a seguir al escribir sus programas PL/SQL es  "una manera de entrar y una salida". En otras palabras, debe haber sólo una manera de entrar o llamar a un programa, y debe haber una salida, una ruta de acceso de un programa (o bucle) en la terminación correcta. Al seguir esta regla, se termina con código que es mucho más fácil de trazar, depurar y mantener.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_procedure IS
      l_idx SIMPLE_INTEGER := 1;
      co_modulo CONSTANT SIMPLE_INTEGER := 7;
   BEGIN
      <<mod7_loop>>
      LOOP
        IF MOD(l_idx,co_modulo) = 0 THEN
           RETURN;
        END IF;

        l_idx := l_idx + 1;
      END LOOP mod7_loop;
   END my_procedure;
END my_package;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_procedure IS
      l_idx SIMPLE_INTEGER := 1;
      co_modulo CONSTANT SIMPLE_INTEGER := 7;
   BEGIN
      <<mod7_loop>>
      LOOP
        EXIT mod7_loop WHEN MOD(l_idx,co_modulo) = 0;

        l_idx := l_idx + 1;
      END LOOP mod7_loop;
   END my_procedure;
END my_package;
/
```

## Funciones

### G-7410: Evite las funciones independientes - ponga sus funciones en paquetes

Utilice los paquetes para estructurar su código, combine procedimientos y funciones que pertenecen juntas.

Los cuerpos de los paquetes se pueden cambiar y compilar sin invalidar otros paquetes. Esta es una gran ventaja en comparación con los procedimientos y funciones independientes.

### G-7420: Siempre haga que la instrucción RETURN sea la última declaración de su función

El lector espera que la instrucción RETURN sea la última instrucción de una función.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function (in_from IN PLS_INTEGER
                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS
      l_ret PLS_INTEGER;
   BEGIN
      l_ret := in_from;
      <<for_loop>>
      FOR i IN in_from .. in_to
      LOOP
         l_ret := l_ret + i;
         IF i = in_to THEN
            RETURN l_ret;
         END IF;
      END LOOP for_loop;
   END my_function;
END my_package;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function (in_from IN PLS_INTEGER
                       , in_to   IN PLS_INTEGER) RETURN PLS_INTEGER IS
      l_ret PLS_INTEGER;
   BEGIN
      l_ret := in_from;
      <<for_loop>>
      FOR i IN in_from .. in_to
      LOOP
         l_ret := l_ret + i;
      END LOOP for_loop;
      RETURN l_ret;
   END my_function;
END my_package;
/
```

### G-7430: Intente utilizar no más de una instrucción RETURN dentro de una función

Una función debe tener un solo punto de entrada así como un solo punto de salida.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS
      co_yes CONSTANT PLS_INTEGER := 1;
   BEGIN
      IF in_value = co_yes THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END my_function;
END my_package;
/

-- BETTER
CREATE OR REPLACE PACKAGE BODY my_package IS FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS
co_yes CONSTANT PLS_INTEGER := 1;
l_ret BOOLEAN;
BEGIN
  IF in_value = co_yes THEN
    l_ret := TRUE;
  ELSE l_ret := FALSE;
  END IF;

  RETURN l_ret;
END my_function; END my_package; /

-- GOOD

CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function (in_value IN PLS_INTEGER) RETURN BOOLEAN IS
      co_yes CONSTANT PLS_INTEGER := 1;
   BEGIN
      RETURN in_value = co_yes;
   END my_function;
END my_package;
/
```

### G-7440: Nunca use los parámetros OUT para devolver los valores de una función

Una función debe devolver todos sus datos a través de la cláusula RETURN. Tener un parámetro OUT prohíbe el uso de una función dentro de las sentencias de SQL.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function (out_date OUT DATE) RETURN BOOLEAN IS
   BEGIN
      out_date := SYSDATE;
      RETURN TRUE;
   END my_function;
END my_package;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function RETURN DATE IS
   BEGIN
      RETURN SYSDATE;
   END my_function;
END my_package;
/
```

### G-7450: Nunca devuelva un valor NULL desde una función BOOLEAN

Si una función booleana devuelve un valor nulo, la persona que llama tiene que lidiar con ella. Esto hace que el uso sea engorroso y más propenso a errores.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function RETURN BOOLEAN IS
   BEGIN
      RETURN NULL;
   END my_function;
END my_package;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   FUNCTION my_function RETURN BOOLEAN IS
   BEGIN
      RETURN TRUE;
   END my_function;
END my_package;
/
```

### G-7460: Intente definir su función empaquetada/independiente determinista si es apropiado

Una función determinista (siempre devuelve el mismo resultado para los parámetros idénticos) que se define como determinista se ejecutará una vez por parámetro diferente dentro de una instrucción SQL mientras que si la función no está definida para ser determinista se ejecuta una vez por fila de resultados.

```sql
-- BAD
CREATE OR REPLACE PACKAGE department_api IS
   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)
      RETURN departments.department_name%TYPE;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE department_api IS
   FUNCTION name_by_id (in_department_id IN departments.department_id%TYPE)
      RETURN departments.department_name%TYPE DETERMINISTIC;
END department_api;
/
```

## Paquetes suministrados por Oracle

### G-7510: Siempre prefija los paquetes provistos por ORACLE con el nombre del esquema del propietario

La firma de los paquetes provistos por oracle es bien conocida y, por lo tanto, es bastante fácil proporcionar paquetes con el mismo nombre que aquellos de oracle que hacen algo completamente diferente sin que te des cuenta.

```sql
-- BAD
DECLARE
   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';
BEGIN
   dbms_output.put_line(co_hello_world);
END;
/

-- GOOD
DECLARE
   co_hello_world CONSTANT STRING(30 CHAR) := 'Hello World';
BEGIN
   sys.dbms_output.put_line(co_hello_world);
END;
/
```

## Tipos de Objetos

## Disparadores/Triggers

### G-7710: Evite los disparadores en cascada

Tener disparadores que actúan en otras tablas de una manera que hace que los disparadores en esa mesa se activen conduce a un comportamiento oscuro.

```sql
-- BAD
CREATE OR REPLACE TRIGGER dept_br_u
BEFORE UPDATE ON departments FOR EACH ROW
BEGIN
   INSERT INTO departments_hist (department_id
                                ,department_name
                                ,manager_id
                                ,location_id
                                ,modification_date)
        VALUES (:OLD.department_id
               ,:OLD.department_name
               ,:OLD.manager_id
               ,:OLD.location_id
               ,SYSDATE);
END;
/
CREATE OR REPLACE TRIGGER dept_hist_br_i
BEFORE INSERT ON departments_hist FOR EACH ROW
BEGIN
   INSERT INTO departments_log (department_id
                               ,department_name
                               ,modification_date)
                        VALUES (:NEW.department_id
                               ,:NEW.department_name
                               ,SYSDATE);
END;
/

-- GOOD
CREATE OR REPLACE TRIGGER dept_br_u
BEFORE UPDATE ON departments FOR EACH ROW
BEGIN
   INSERT INTO departments_hist (department_id
                                ,department_name
                                ,manager_id
                                ,location_id
                                ,modification_date)
        VALUES (:OLD.department_id
               ,:OLD.department_name
               ,:OLD.manager_id
               ,:OLD.location_id
               ,SYSDATE);

   INSERT INTO departments_log (department_id
                               ,department_name
                               ,modification_date)
                        VALUES (:OLD.department_id
                               ,:OLD.department_name
                               ,SYSDATE);

END;
/
```

## Sequencias

### G-7810: Nunca use SQL dentro de PL / SQL para leer números de secuencia (o SYSDATE)

Desde ORACLE 11g ya no es necesario usar una instrucción SELECT para leer una secuencia (lo que implicaría un cambio de contexto).

```sql
-- BAD
DECLARE
   l_sequence_number employees.emloyee_id%type;
BEGIN
   SELECT employees_seq.NEXTVAL
     INTO l_sequence_number
     FROM DUAL;
END;
/

-- GOOD
DECLARE
   l_sequence_number employees.emloyee_id%type;
BEGIN
   l_sequence_number := employees_seq.NEXTVAL;
END;
/
```

## Patrones

### G-8110: Nunca use SELECT COUNT(*) si solo está interesado en la existencia de una fila

Si realiza un SELECT COUNT() todas las filas se leerán de acuerdo con la cláusula WHERE, aunque sólo sea de interés la disponibilidad de los datos. Para ello tenemos una gran sobrecarga de rendimiento.

Si hacemos un SELECT COUNT() ... WHERE ROWNUM  = 1 también hay una sobrecarga ya que habrá dos comunicaciones entre el PL/SQL y el motor SQL.

Vea el siguiente ejemplo para una mejor solución.

```sql
-- BAD
DECLARE
   l_count PLS_INTEGER;
   co_zero   CONSTANT SIMPLE_INTEGER := 0;
   co_salary CONSTANT employees.salary%TYPE := 5000;
BEGIN
   SELECT count(*)
     INTO l_count
     FROM employees
    WHERE salary < co_salary;
    IF l_count > co_zero THEN
       <<emp_loop>>
       FOR r_emp IN (SELECT employee_id
                       FROM employees)
       LOOP
          IF r_emp.salary < co_salary THEN
             my_package.my_proc(in_employee_id => r_emp.employee_id);
          END IF;
       END LOOP emp_loop;
    END IF;
END;
/

-- GOOD
DECLARE
   co_salary CONSTANT employees.salary%TYPE := 5000;
BEGIN
    <<emp_loop>>
    FOR r_emp IN (SELECT e1.employee_id
                    FROM employees e1
                   WHERE EXISTS(SELECT e2.salary
                                  FROM employees e2
                                 WHERE e2.salary < co_salary))
    LOOP
       my_package.my_proc(in_employee_id => r_emp.employee_id);
    END LOOP emp_loop;
END;
/
```

### G-8120: Nunca verifique la existencia de una fila para decidir si crearla o no

El resultado de una comprobación de existencia es una instantánea de la situación actual. Nunca se sabe si en el tiempo entre el check y la acción (Insert) otra persona ha decidido crear una fila con los valores que ha comprobado. Por lo tanto, sólo debe depender de restricciones cuando se trata de preventioin de registros duplicados.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY department_api IS
   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS
      l_count PLS_INTEGER;
   BEGIN
      SELECT count(*)
        INTO l_count
        FROM departments
       WHERE department_id = in_r_department.department_id;

       IF l_count = 0 THEN
          INSERT INTO departments
               VALUES in_r_department;
       END IF;
   END ins;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY department_api IS
   PROCEDURE ins (in_r_department IN departments%ROWTYPE) IS
   BEGIN
      INSERT INTO departments
           VALUES in_r_department;
   EXCEPTION
      WHEN dup_val_on_index THEN NULL; -- handle exception
   END ins;
END department_api;
/
```

## Acceso a objetos de esquemas de aplicaciones externas

### G-8210: Siempre use sinónimos cuando acceda a objetos de otro esquema de aplicación

Si se necesita una conexión a una tabla que se coloca en un esquema externo, el uso de sinónimos es una buena opción. Si hay cambios estructurales en esa tabla (por ejemplo, los cambios en el nombre de la tabla o la tabla cambia a otro esquema) sólo se debe cambiar el sinónimo no se necesitan cambios en el paquete (punto único de cambio).

Si sólo tiene acceso de lectura para una tabla dentro de otro esquema, o hay otra razón que no le permite cambiar datos en esta tabla, puede cambiar el sinónimo a una tabla en su propio esquema. Esta es también una buena práctica para los evaluadores que trabajan en sistemas de prueba.

```sql
-- BAD
DECLARE
   l_product_name oe.products.product_name%TYPE;
   co_price CONSTANT oe.products@list_price%TYPE := 1000;
BEGIN
   SELECT p.product_name
     INTO l_product_name
     FROM oe.products p
    WHERE list_price > co_price;
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      NULL; -- handle_no_data_found;
   WHEN TOO_MANY_ROWS THEN
      NULL; -- handle_too_many_rows;
END;
/

-- GOOD
CREATE SYNONYM oe_products FOR oe.products;

DECLARE
   l_product_name oe_products.product_name%TYPE;
   co_price CONSTANT oe_products.list_price%TYPE := 1000;
BEGIN
   SELECT p.product_name
     INTO l_product_name
     FROM oe_products p
    WHERE list_price > co_price;
EXCEPTION
   WHEN NO_DATA_FOUND THEN
      NULL; -- handle_no_data_found;
   WHEN TOO_MANY_ROWS THEN
      NULL; -- handle_too_many_rows;
END;
/
```

## Validar el tamaño del parámetro de entrada

### G-8310: Valide siempre el tamaño del parámetro de entrada asignando el parámetro a una variable de tamaño limitado en la sección de declaración de la unidad del programa

Esta técnica genera un error (value_error) que no se puede manejar en la unidad de programa llamada. Esta es la forma correcta de hacerlo, ya que el error no está dentro de esta unidad, pero cuando lo llama, por lo que la persona que llama debe manejar el error.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)
      RETURN departments%ROWTYPE IS
      l_return departments%rowtype;
   BEGIN
       IF    in_dept_name IS NULL
          OR LENGTH(in_dept_name) > 20
       THEN
          RAISE err.e_param_to_large;
       END IF;
       -- get the department by name
       SELECT *
         FROM departments
        WHERE department_name = in_dept_name;

       RETURN l_return;
   END dept_by_name;
END department_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY department_api IS
   FUNCTION dept_by_name (in_dept_name IN departments.department_name%TYPE)
      RETURN departments%ROWTYPE IS
      l_dept_name departments.department_name%TYPE NOT NULL := in_dept_name;
      l_return departments%rowtype;
   BEGIN
       -- get the department by name
       SELECT *
         FROM departments
        WHERE department_name = l_dept_name;

       RETURN l_return;
   END dept_by_name;
END department_api;
/

-- Function call
...
   r_deparment := department_api.dept_by_name('Far to long name of a department');
...
EXCEPTION
   WHEN VALUE_ERROR THEN ...
```

## Garantizar una ejecución única en un momento de una unidad de programa

### G-8410: Utilice siempre los bloqueos de aplicaciones para garantizar que una unidad de programa solo se ejecute una vez en un momento dado

Esta técnica nos permite tener bloqueos a través de transacciones así como una manera probada de limpiar al final de la sesión.

La alternativa que utiliza una tabla donde se almacena una "fila-bloqueada" tiene la desventaja que en caso de un error una limpieza apropiada tiene que ser hecha para "desbloquear" la unidad del programa.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY lock_up IS
   FUNCTION request_lock (in_lock_name         IN VARCHAR2
                         ,in_release_on_commit IN BOOLEAN := FALSE) RETURN VARCHAR2 IS
      l_lock_handle VARCHAR2(128 CHAR);
   BEGIN
      SYS.DBMS_LOCK.ALLOCATE_UNIQUE (lockname        => in_lock_name
                                    ,lockhandle      => l_lock_handle
                                    ,expiration_secs => constants_up.co_one_week);

      IF sys.DBMS_LOCK.REQUEST(lockhandle        => l_lock_handle
                              ,lockmode          => sys.DBMS_LOCK.X_MODE
                              ,TIMEOUT           => sys.DBMS_LOCK.MAXWAIT
                              ,release_on_commit => COALESCE(in_release_on_commit
                                                            ,FALSE)) > 0 THEN
         RAISE err.e_lock_request_failed;
      END IF;

      RETURN l_lock_handle;
   END request_lock;

   PROCEDURE release_lock (in_lock_handle IN VARCHAR2) IS
   BEGIN
     IF sys.DBMS_LOCK.RELEASE(lockhandle => in_lock_handle) > 0 THEN
         RAISE err.e_lock_request_failed;
     END IF;
   END release_lock;
END lock_up;
/

-- GOOD
DECLARE
   l_handle VARCHAR2(128 CHAR);
   co_lock_name CONSTANT VARCHAR2(30 CHAR) := 'APPLICATION_LOCK';
BEGIN
   l_handle := lock_up.request_lock(in_lock_name => co_lock_name);
   -- processing
   lock_up.release_lock(in_lock_handle => l_handle);
EXCEPTION
   WHEN OTHERS THEN
      -- log error
      lock_up.release_lock(in_lock_handle => l_handle);
      RAISE;
END;
/
```

## Utilice el paquete DBMS_APPLICATION_INFO para seguir el progreso de un proceso

### G-8420: Siempre use DBMS_APPLICATION_INFO para rastrear el proceso del programa de forma transitoria

Esta técnica nos permite ver el progreso de un proceso sin tener que escribir de forma persistente los datos de registro en una tabla o un archivo. La información es accesible a través de la vista V$SESSION.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   PROCEDURE process_emps IS
   BEGIN
      <<employees>>
      FOR emp_rec IN (SELECT employee_id
                        FROM employees
                       ORDER BY employee_id)
      LOOP
         NULL; -- some processing
      END LOOP employees;
   END process_emps;
END employee_api;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api IS
   PROCEDURE process_emps IS
   BEGIN
      SYS.DBMS_APPLICATION_INFO.SET_MODULE(module_name => $$PLSQL_UNIT
                                          ,action_name => 'Init');
      <<employees>>
      FOR emp_rec IN (SELECT employee_id
                        FROM employees
                       ORDER BY employee_id)
      LOOP
         SYS.DBMS_APPLICATION_INFO.SET_ACTION('Processing ' || emp_rec.employee_id);
      END LOOP employees;
   end process_emps;
END employee_api;
/
```
