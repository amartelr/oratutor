# General
### G-1010: Intenta etiquetar tus sub-bloques

Intenta etiquetar tus sub bloques, ya que es una buena alternativa para que los comentarios indiquen el inicio y el final de un procesamiento con nombre.

#### Ejemplo

```sql
BEGIN
   <<prepare_data>>
   BEGIN 
      NULL;
   END prepare_data;

   <<process_data>>
   BEGIN
      NULL;
   END process_data;
END good;
/
```

### G-1020: Siempre tenga una etiqueta de bucle o bloque coincidente

La razón de usar Utilice una etiqueta directamente delante de bucles y bloques anónimos anidados es:

- Dar un nombre a esa porción de código y por lo tanto auto-documentar lo que está haciendo.

- Para que pueda repetir ese nombre con la instrucción END de ese bloque o bucle.

```sql
DECLARE
   i INTEGER;
   co_min_value CONSTANT INTEGER := 1;
   co_max_value CONSTANT INTEGER := 10;
   co_increment CONSTANT INTEGER := 1;
BEGIN
   <<prepare_data>>
   BEGIN 
      NULL;
   END prepare_data;

   <<process_data>>
   BEGIN
      NULL;
   END process_data;

   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value) 
   LOOP 
      i := i + co_increment; 
   END LOOP while_loop;

   <<basic_loop>>
   LOOP 
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP 
     sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/
```

### G-1030: Avoid defining variables that are not used

Evite definir variables que no se utilicen

### G-1040: Evitar el código muerto

Cualquier parte de su código, que ya no se usa o no se puede alcanzar, debe eliminarse de sus programas para simplificar el código.

### G-1050: Evita usar literales en tu código

Los literales a menudo se usan más de una vez en su código. Tenerlos definidos como una constante reduce los errores tipográficos en su código y mejora la capacidad de mantenimiento.

Todas **las constantes se deben recopilar en un solo paquete utilizado como biblioteca**. Si estas constantes también deberían usarse en SQL, es una buena práctica escribir una función de paquete determinista para cada constante.

```sql
CREATE OR REPLACE PACKAGE constants_up IS
   co_president CONSTANT employees.job_id%TYPE := 'AD_PRES';
END constants_up;
/

DECLARE
   l_job employees.job_id%TYPE;
BEGIN
   SELECT e.job_id
     INTO l_job
     FROM employees e
    WHERE e.manager_id IS NULL;

   IF l_job = constants_up.co_president THEN
      NULL;
   END IF;
EXCEPTION
   WHEN NO_DATA_FOUND THEN 
      NULL; -- handle_no_data_found;
   WHEN TOO_MANY_ROWS THEN 
      NULL; -- handle_too_many_rows; 
END;
/
```

### G-1060: Evite almacenar ROWID o UROWID en tablas de base de datos

Es una práctica extremadamente peligrosa almacenar ROWIDs en una tabla, a excepción de algunos escenarios muy limitados de duración de tiempo de ejecución. Cualquier reorganización de tabla implícita manualmente explícita o generada por el sistema reasignará el ROWID de la fila y romperá la consistencia de los datos.

En lugar de usar ROWID para una referencia posterior a la fila original, uno debe usar la(s) columna(s) de clave primaria.

### G-1070: Evitar anidar bloques de comentarios

Tener un final de comentario dentro de un comentario de bloque terminará ese comentario de bloque. Esto no solo influye en su código sino que también es muy difícil de leer.

# Variables y Tipos

## General

### G-2110: Trate de usar declaraciones ancladas para variables, constantes y tipos

Si se cambia el tamaño de la columna de base de datos last_name en la tabla Employees de VARCHAR2(20) a VARCHAR2(30) se producirá un error en el código siempre que se lea de la tabla un valor mayor que el tamaño codificado en formato duro. Esto se puede evitar utilizando declaraciones ancladas.

```sql
-- BAD
   l_last_name  VARCHAR2(20 CHAR);
-- GOOD
   l_last_name  employees.last_name%TYPE;
```

### G-2120: Intente tener una sola ubicación para definir tus tipos

Único punto de cambio al cambiar el tipo de datos. No es necesario discutir dónde definir tipos o dónde buscar definiciones existentes.

Una única ubicación podría ser **un paquete de especificación de tipo o la base de datos** (tipos definidos por la base de datos).

```sql
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);
END types_up;
/

CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_proc IS
      l_note types_up.big_string_type;
   BEGIN
      l_note := some_function();
   END my_proc;
END my_package;
/
```

### G-2130: Trate de usar subtipos para construcciones usadas a menudo en su código

Único punto de cambio al cambiar el tipo de datos. Su código será más fácil de leer, ya que el uso de una variable/ constante puede derivarse de su definición.

#### Ejemplos de posibles definiciones de subtipo
|Tipo |Uso  |
|-----|-----|
|ora_name_type	| Objeto correspondiente a los convenios de denominación de ORACLE (tabla, variable, columna, paquete, etc.).|
|max_vc2_type | Variable de cadena con tamaño máximo VARCHAR2.|
|array_index_type | El mejor tipo de datos de ajuste para la navegación de matriz.
|id_type| Tipo de datos utilizado para todas las columnas de clave primaria (id).

#### Ejemplo

```sql
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE big_string_type IS VARCHAR2(1000 CHAR);
END types_up;
/

CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE my_proc IS
      l_note types_up.big_string_type;
   BEGIN
      l_note := some_function();
   END my_proc;
END my_package;
/
```

### G-2140: Nunca inicializar variables con NULL

Las variables se inicializan a NULL de forma predeterminada.

### G-2150: Evite las comparaciones con el valor NULL, considere usar IS [NOT] NULL

El valor NULL puede causar confusión tanto desde el punto de vista de la revisión del código como de la ejecución del código. Siempre debe usar la sintaxis IS NULL o IS NOT NULL cuando necesite verificar si un valor es o no es NULL.

```sql
-- BAD
DECLARE
   l_value INTEGER;
BEGIN
   IF l_value = NULL THEN
      NULL;
   END IF;
END;
/
-- GOOD
DECLARE
   l_value INTEGER;
BEGIN
   IF l_value IS NULL THEN
      NULL;
   END IF;
END;
/
```

### G-2160: Evite inicializar variables usando funciones en la sección de declaración

Si su inicialización falla, no podrá manejar el error en su bloque de excepciones.

```sql
-- BAD
DECLARE
   co_department_id CONSTANT INTEGER := 100;
   l_department_name departments.department_name%TYPE := 
      department_api.name_by_id(in_id => co_department_id);
BEGIN
   sys.dbms_output.put_line(l_department_name);
END;
/
-- GOOD
DECLARE
   co_department_id  CONSTANT INTEGER := 100;
   co_unkown_name    CONSTANT departments.department_name%TYPE := 'unknown';
   l_department_name departments.department_name%TYPE;
BEGIN
   <<init>>
   BEGIN
      l_department_name := department_api.name_by_id(in_id => co_department_id);
   EXCEPTION
      WHEN value_error THEN
         l_department_name := co_unkown_name;
   END init;

   sys.dbms_output.put_line(l_department_name);
END;
/
```

### G-2170: Nunca sobrecargar las variables

La legibilidad de su código será mayor cuando no sobrecargue las variables.

```sql
-- BAD
BEGIN 
   <<main>>
   DECLARE
      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';
      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';
      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';
      l_variable user_objects.object_name%TYPE := co_main;
   BEGIN
      <<sub>>
      DECLARE
         l_variable user_objects.object_name%TYPE := co_sub;
      BEGIN
         sys.dbms_output.put_line(l_variable || co_sep || main.l_variable);
      END sub;
   END main;
END;
/
-- GOOD
BEGIN 
   <<main>>
   DECLARE
      co_main CONSTANT user_objects.object_name%TYPE := 'test_main';
      co_sub CONSTANT user_objects.object_name%TYPE := 'test_sub';
      co_sep CONSTANT user_objects.object_name%TYPE := ' - ';
      l_main_variable user_objects.object_name%TYPE := co_main;
   BEGIN
      <<sub>>
      DECLARE
         l_sub_variable user_objects.object_name%TYPE := co_sub;
      BEGIN
         sys.dbms_output.put_line(l_sub_variable || co_sep || l_main_variable);
      END sub;
   END main;
END;
/
```

### G-2180: Nunca use identificadores entre comillas

Los identificadores entre comillas hacen que su código sea difícil de leer y mantener.

### G-2185: Evite utilizar nombres demasiado cortos para identificadores declarados explícita o implícitamente

Usted debe asegurarse de que el nombre que ha elegido bien define su propósito y uso. Mientras que usted puede ahorrar algunas pulsaciones tecleando nombres muy cortos, el código resultante es obscuro y duro para cualquier persona además del autor para entender.

```sql
-- BAD
DECLARE
   i INTEGER;
   c CONSTANT INTEGER := 1;
   e EXCEPTION;
BEGIN
   i := c;
EXCEPTION
   WHEN e THEN
      NULL;
END;
/
-- GOOD
DECLARE
   l_sal_comm     INTEGER;
   co_my_constant CONSTANT INTEGER := 1;
   e_my_exception EXCEPTION;
BEGIN
   l_sal_comm := co_my_constant;
EXCEPTION
   WHEN e_my_exception THEN
      NULL;
END;
/
```

### G-2190: Evite utilizar ROWID o UROWID

Tenga cuidado con el uso de tipos de datos específicos de Oracle como ROWID y UROWID. Pueden ofrecer una leve mejora en el rendimiento con respecto a otros medios de identificar una sola fila (clave principal o valor de índice único), pero eso no está garantizado de ninguna manera.

El uso de ROWID o UROWID significa que su declaración SQL no será portable a otras bases de datos SQL. Muchos desarrolladores también no están familiarizados con estos tipos de datos, que pueden hacer el código más difícil de mantener.

## Tipos Numéricos

### G-2210: Evite declarar NUMBER variables, constantes o subtipos sin precisión

Si no especifica la precisión, el NÚMERO está predeterminado a 38 o el máximo admitido por su sistema, el que sea menor. Es posible que necesite toda esta precisión, pero si sabe que no, debe especificar lo que se adapte a sus necesidades.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_small_increase CONSTANT NUMBER := 0.1;

   FUNCTION small_increase RETURN NUMBER IS
   BEGIN
      RETURN co_small_increase;
   END small_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_small_increase CONSTANT NUMBER(5,1) := 0.1;

   FUNCTION small_increase RETURN NUMBER IS
   BEGIN
      RETURN co_small_increase;
   END small_increase;
END constants_up;
/
```

### G-2220: Trate de usar PLS_INTEGER en lugar de NUMBER para operaciones aritméticas con valores enteros

PLS_INTEGER con una longitud de -2,147,483,648 a 2,147,483,647, en un sistema de 32 bits.
Hay muchas razones para usar PLS_INTEGER en lugar de NUMBER:

- PLS_INTEGER usa menos memoria
- PLS_INTEGER utiliza aritmética de máquina, que es hasta tres veces más rápida que la aritmética de biblioteca, que es utilizada por NÚMERO.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT NUMBER(5,0) := 1;

   FUNCTION big_increase RETURN NUMBER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT PLS_INTEGER := 1;

   FUNCTION big_increase RETURN PLS_INTEGER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
```

### G-2230: Try to use SIMPLE_INTEGER datatype when appropriate.

Trate de usar el tipo de datos SIMPLE_INTEGER cuando sea apropiado para ORACLE 11g o posterior.

SIMPLE_INTEGER no verifica el desbordamiento numérico, lo que resulta en un mejor rendimiento en comparación con los otros tipos de datos numéricos.

Con ORACLE 11g, se ha introducido el nuevo tipo de datos SIMPLE_INTEGER. Es un sub-tipo de PLS_INTEGER y cubre la misma gama. 

La diferencia básica es que SIMPLE_INTEGER siempre no es NULL. Cuando el valor de la variable declarada nunca va a ser null, entonces puede declararlo como SIMPLE_INTEGER.

Otra diferencia importante es que nunca se enfrentará a un desbordamiento numérico utilizando SIMPLE_INTEGER como este tipo de datos envuelve alrededor sin dar ningún error.

El tipo de datos SIMPLE_INTEGER proporciona un mayor rendimiento en PLS_INTEGER cuando el código se compila en modo nativo, ya que las operaciones aritméticas en el tipo SIMPLE_INTEGER se realizan directamente a nivel de hardware.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT NUMBER(5,0) := 1;

   FUNCTION big_increase RETURN NUMBER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_big_increase CONSTANT SIMPLE_INTEGER := 1;

   FUNCTION big_increase RETURN SIMPLE_INTEGER IS
   BEGIN
      RETURN co_big_increase;
   END big_increase;
END constants_up;
/
```

## Tipos Carácter

### G-2310: Avoid using CHAR data type.

Evite utilizar el tipo de datos CHAR. CHAR es un tipo de datos de longitud fija, que solo debe usarse cuando sea apropiado. Las columnas/variables CHAR siempre se llenan en sus longitudes especificadas; Esto puede llevar a efectos secundarios no deseados y resultados no deseados.

```sql
-- BAD
CREATE OR REPLACE PACKAGE types_up 
IS
   SUBTYPE description_type IS CHAR(200);
END types_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE types_up 
IS
   SUBTYPE description_type IS VARCHAR2(200 CHAR);
END types_up;
/
```

### G-2320: Evite usar el tipo de datos VARCHAR

No utilice el tipo de datos VARCHAR. En su lugar, utilice el tipo de datos VARCHAR2. Aunque el tipo de datos VARCHAR es actualmente sinónimo de VARCHAR2, el tipo de datos VARCHAR está programado para ser redefinido como un tipo de datos separado utilizado para cadenas de caracteres de longitud variable en comparación con diferentes semánticas de comparación.

### G-2330: Nunca use cadenas de longitud cero para sustituir NULL

Hoy en día, las cadenas de longitud cero y NULL actualmente se manejan de forma idéntica por ORACLE. No hay garantía de que este sea el caso en futuras versiones, por lo tanto, si quiere decir NULL use NULL.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY constants_up IS
   co_null_string CONSTANT VARCHAR2(1) := '';

   FUNCTION null_string RETURN VARCHAR2 IS 
   BEGIN
       RETURN co_null_string;
   END null_string;
END constants_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY constants_up IS

   FUNCTION empty_string RETURN VARCHAR2 IS 
   BEGIN
       RETURN NULL;
   END empty_string;
END constants_up;
/
```

### G-2340: Siempre defina sus variables VARCHAR2 usando CHAR SEMANTIC (si no está definido anclado)

Los cambios en el NLS_LENGTH_SEMANTIC solo serán recogidos por su código después de una recompilación.

En un entorno multibyte, una definición VARCHAR2(10) puede no contener necesariamente 10 caracteres, cuando los caracteres multibyte forman parte del valor que debe almacenarse, a menos que la definición se haya realizado con el carácter semántico.

```sql
-- BAD
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE description_type IS VARCHAR2(200);
END types_up;
/
-- GOOD
CREATE OR REPLACE PACKAGE types_up IS
   SUBTYPE description_type IS VARCHAR2(200 CHAR);
END types_up;
/
```

## Tipos Booleanos

### G-2410: Trate de usar el tipo de datos booleano para valores con doble significado

El uso de TRUE y FALSE aclara que este es un valor booleano y hace que el código sea más fácil de leer.

```sql
-- BAD
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger   PLS_INTEGER;
BEGIN
   IF co_newFile < co_oldFile THEN
      l_bigger := constants_up.co_numeric_true;
   ELSE
      l_bigger := constants_up.co_numeric_false;
   END IF;
END;
/
-- BETTER
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger  BOOLEAN;
BEGIN
   IF co_newFile < co_oldFile THEN
      l_bigger := TRUE;
   ELSE
      l_bigger := FALSE;
   END IF;
END;
/
-- GOOD
DECLARE
   co_newFile CONSTANT PLS_INTEGER := 1000;
   co_oldFile CONSTANT PLS_INTEGER := 500;
   l_bigger  BOOLEAN;
BEGIN
   l_bigger := NVL(co_newFile < co_oldFile,FALSE);
END;
/
```

## Large Objetos

### G-2510: Evite utilizar los tipos de datos LONG y LONG RAW

ORACLE ha desaprobado los tipos de datos LONG y LONG RAW desde la versión 8i: el soporte podría suspenderse en futuras versiones de ORACLE.

Existen muchas restricciones para los tipos de datos LONG en comparación con los tipos de LOB.

```sql
-- BAD
CREATE OR REPLACE PACKAGE example_package IS
   g_long LONG;
   g_raw  LONG RAW;

   PROCEDURE do_something;
END example_package;
/

CREATE OR REPLACE PACKAGE BODY example_package IS
   PROCEDURE do_something IS
   BEGIN 
      NULL;
   END do_something;
END example_package;
/
-- GOOD
CREATE OR REPLACE PACKAGE example_package IS
   PROCEDURE do_something;
END example_package;
/

CREATE OR REPLACE PACKAGE BODY example_package IS
   g_long CLOB;
   g_raw  BLOB;

   PROCEDURE do_something IS
   BEGIN 
      NULL;
   END do_something;
END example_package;
/
```

# DML / SQL

## General

### G-3110: Siempre especifique las columnas de destino al codificar una instrucción de inserción

Las estructuras de datos a menudo cambian. Tener las columnas de destino en sus declaraciones de inserción dará lugar a un código resistente al cambio.

```sql
-- BAD
INSERT INTO departments
     VALUES (departments_seq.nextval
            ,'Support'
            ,100
            ,10);
-- GOOD
INSERT INTO departments (department_id 
                        ,department_name
                        ,manager_id
                        ,location_id)
     VALUES (departments_seq.nextval
            ,'Support'
            ,100
            ,10);
```

### G-3120: Siempre use alias de tablas cuando su declaración SQL involucre más de una fuente

Es más legible para los humanos usar alias en lugar de escribir columnas sin información de tablas. Especialmente cuando se usan subconsultas, la omisión de alias de tablas puede terminar en un comportamiento y resultado inesperado.

```sql
-- BAD
SELECT last_name
      ,first_name
      ,department_name
  FROM      employees  
       JOIN departments USING (department_id)
 WHERE EXTRACT(MONTH FROM hire_date) = EXTRACT(MONTH FROM SYSDATE);
-- BETTER
SELECT e.last_name
      ,e.first_name
      ,d.department_name
  FROM      employees   e
       JOIN departments d ON (e.department_id = d.department_id)
 WHERE EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);

-- GOOD
-- El uso de alias significativos mejora la legibilidad de su código.

SELECT emp.last_name
      ,emp.first_name
      ,dept.department_name
  FROM      employees   emp
       JOIN departments dept ON (emp.department_id = dept.department_id)
 WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);
```

### G-3130: Trate de usar la sintaxis de unión ANSI

La sintaxis de unión ANSI admite la unión externa completa. Otra ventaja de la sintaxis de unión ANSI es la separación de la condición de unión de los filtros de consulta.

```sql
-- BAD
SELECT e.employee_id
      ,e.last_name
      ,e.first_name
      ,d.department_name
  FROM employees e
      ,departments d 
 WHERE e.department_id = d.department_id
   AND EXTRACT(MONTH FROM e.hire_date) = EXTRACT(MONTH FROM SYSDATE);
/
-- GOOD
SELECT emp.employee_id
      ,emp.last_name
      ,emp.first_name
      ,dept.department_name
  FROM      employees   emp
       JOIN departments dept ON dept.department_id = emp.department_id
 WHERE EXTRACT(MONTH FROM emp.hire_date) = EXTRACT(MONTH FROM SYSDATE);
```

### G-3140: Trate de usar registros anclados como objetivos para sus cursores. ROWTYPE.

El uso de registros anclados por el cursor como objetivos para los resultados de sus cursores permite la posibilidad de cambiar la estructura del cursor sin tener en cuenta la estructura del objetivo.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, first_name, last_name
        FROM employees;
   l_employee_id employees.employee_id%TYPE;
   l_first_name  employees.first_name%TYPE;
   l_last_name   employees.last_name%TYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;
   <<process_employees>>
   WHILE c_employees%FOUND
   LOOP
      -- do something with the data
      FETCH c_employees INTO l_employee_id, l_first_name, l_last_name;
   END LOOP process_employees;
   CLOSE c_employees;
END;
/
-- GOOD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, first_name, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO r_employee;
   <<process_employees>>
   WHILE c_employees%FOUND
   LOOP
      -- do something with the data
      FETCH c_employees INTO r_employee;
   END LOOP process_employees;
   CLOSE c_employees;
END;
/
```

### G-3150: Trate de usar columnas de identidad para las claves sustitutas. *ORACLE 12c*


Una columna de identidad es una clave sustituta por diseño – no hay razón por la cual no debemos aprovechar esta implementación natural cuando las claves se generan en el nivel de base de datos. El uso de la columna de identidad (y, por tanto, la asignación de secuencias como valores predeterminados en las columnas) tiene una gran ventaja de rendimiento sobre una solución desencadenante.

```sql
-- BAD
CREATE TABLE locations (
   location_id        NUMBER(10)        NOT NULL 
  ,location_name      VARCHAR2(60 CHAR) NOT NULL
  ,city               VARCHAR2(30 CHAR) NOT NULL
  ,CONSTRAINT locations_pk PRIMARY KEY (location_id)
  )
/

CREATE SEQUENCE location_seq START WITH 1 CACHE 20
/

CREATE OR REPLACE TRIGGER location_br_i 
   BEFORE INSERT ON LOCATIONS 
   FOR EACH ROW 
BEGIN
   :new.location_id := location_seq.nextval;
END;
/
-- GOOD
CREATE TABLE locations (
   location_id        NUMBER(10)  GENERATED ALWAYS AS IDENTITY 
  ,location_name      VARCHAR2(60 CHAR) NOT NULL
  ,city               VARCHAR2(30 CHAR) NOT NULL
  ,CONSTRAINT locations_pk PRIMARY KEY (location_id))
/
```

### G-3160: Avoid virtual columns to be visible. *ORACLE 12c*

Evita que las columnas virtuales sean visibles.

En contraste con las columnas visibles, las columnas invisibles no forman parte de un registro definido mediante la construcción% RowType. Esto es útil ya que una columna virtual no se puede rellenar mediante programación. Si su columna virtual es visible, tendrá que definir manualmente los tipos de registro utilizados en los paquetes de API para poder excluirlos de ser parte de la definición de registro.

Se puede acceder a las columnas invisibles añadiendo explícitamente a la lista de columnas en una instrucción SELECT.

```sql
-- BAD
ALTER TABLE employees
   ADD total_salary GENERATED ALWAYS AS (salary + NVL(commission_pct,0) * salary)
/

DECLARE
   r_employee employees%ROWTYPE;
   l_id employees.employee_id%TYPE := 107;
BEGIN
   r_employee := employee_api.employee_by_id(l_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   UPDATE employees
      SET ROW = r_employee
    WHERE employee_id = l_id;
END;
/

Error report -
ORA-54017: UPDATE operation disallowed ON virtual COLUMNS
ORA-06512: at line 9

-- GOOD
ALTER TABLE employees
   ADD total_salary INVISIBLE GENERATED ALWAYS AS 
      (salary + NVL(commission_pct,0) * salary)
/

DECLARE
   r_employee employees%ROWTYPE;
   co_id CONSTANT employees.employee_id%TYPE := 107;
BEGIN
   r_employee := employee_api.employee_by_id(co_id);
   r_employee.salary := r_employee.salary * constants_up.small_increase();

   UPDATE employees
      SET ROW = r_employee
    WHERE employee_id = co_id;
END;
/
```

### G-3170: Siempre use las declaraciones DEFAULT ON NULL para asignar valores predeterminados a las columnas de la tabla si se niega a almacenar valores NULL. *ORACLE 12c*

Los valores predeterminados han sido anulables hasta Oracle 12C. Lo que significa que cualquier herramienta que envía NULL como un valor para una columna que tiene un valor predeterminado omite el valor predeterminado. Comenzando con Oracle 12C las definiciones predeterminadas pueden tener una definición en NULL además, que asignará el valor por defecto en caso de un valor null también.

```sql
-- BAD
CREATE TABLE null_test (
   test_case        NUMBER(2) NOT NULL
  ,column_defaulted VARCHAR2(10) DEFAULT 'Default')
/
INSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');
INSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);
INSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);

SELECT * FROM null_test;

TEST_CASE  COLUMN_DEF
---------  -----------
        1  Value
        2  Default
        3

-- GOOD
CREATE TABLE null_test (
   test_case        NUMBER(2) NOT NULL
  ,column_defaulted VARCHAR2(10) DEFAULT ON NULL 'Default')
/
INSERT INTO null_test(test_case, column_defaulted) VALUES (1,'Value');
INSERT INTO null_test(test_case, column_defaulted) VALUES (2,DEFAULT);
INSERT INTO null_test(test_case, column_defaulted) VALUES (3,NULL);

SELECT * FROM null_test;

 TEST_CASE COLUMN_DEF
---------- ----------
         1 Value     
         2 Default   
         3 Default
```

### G-3180: Siempre especifique nombres de columna en lugar de referencias posicionales en cláusulas ORDER BY

Si usted cambia su lista selecta después la orden cerca todavía funcionará pero orden sus filas diferentemente, al no cambiar el número posicional. Además, no es cómodo para los lectores del código, si tienen que contar las columnas en la lista de selección para saber la forma en que se ordena el resultado.

### G-3190: Evite el uso de NATURAL JOIN

Una combinación natural une tablas en columnas con nombres iguales. Esto puede caber cómodamente a primera vista, pero agregar columnas de registro a una tabla (changed_by, changed_date) resultará en condiciones de unión inapropiadas.

```sql
-- BAD
SELECT department_name 
      ,last_name 
      ,first_name 
  FROM employees NATURAL JOIN departments
 ORDER BY department_name 
         ,last_name;
DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William             
Executive                      De Haan                   Lex                 
…

ALTER TABLE departments ADD modified_at DATE DEFAULT ON NULL SYSDATE;
ALTER TABLE employees ADD modified_at DATE DEFAULT ON NULL SYSDATE;

SELECT department_name 
      ,last_name 
      ,first_name 
  FROM employees NATURAL JOIN departments
 ORDER BY department_name 
         ,last_name;

No data found

-- GOOD
SELECT d.department_name 
      ,e.last_name 
      ,e.first_name 
  FROM employees   e
  JOIN departments d ON (e.department_id = d.department_id)
 ORDER BY d.department_name 
         ,e.last_name;

DEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         
------------------------------ ------------------------- --------------------
Accounting                     Gietz                     William             
Executive                      De Haan                   Lex                 
…
```

## Operaciones BULK

### G-3210: Siempre use BULK OPERATIONS (BULK COLLECT, FORALL) cuando tenga que ejecutar una declaración DML más de 4 veces

Los cambios de contexto entre PL/SQL y SQL son extremadamente costosos. Las operaciones  BULK reducen el número de conmutadores al pasar una matriz al motor SQL, que se usa para ejecutar las declaraciones dadas repetidamente.

(Dependiendo del parámetro PLSQL_OPTIMIZE_LEVEL, el compilador PL/SQL realizará automáticamente una conversión a BULK COLLECT).

```sql
-- BAD
DECLARE
   t_employee_ids employee_api.t_employee_ids_type;
   co_increase CONSTANT employees.salary%type := 0.1;
   co_department_id CONSTANT departments.department_id%TYPE := 10;
BEGIN
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in => co_department_id
                     );
   <<process_employees>>
   FOR i IN 1..t_employee_ids.COUNT()
   LOOP
      UPDATE employees
         SET salary = salary + (salary * co_increase)
       WHERE employee_id = t_employee_ids(i);
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   t_employee_ids   employee_api.t_employee_ids_type;
   co_increase      CONSTANT employees.salary%type := 0.1;
   co_department_id CONSTANT departments.department_id%TYPE := 10;
BEGIN
   t_employee_ids := employee_api.employee_ids_by_department(
                        id_in => co_department_id
                     );
   <<process_employees>>
   FORALL i IN 1..t_employee_ids.COUNT()
      UPDATE employees
         SET salary = salary + (salary * co_increase)
       WHERE employee_id = t_employee_ids(i);
END;
/
```

# Estructuras de Control

## CURSOR

### G-4110: Siempre use %NOTFOUND en lugar de NOT ... %FOUND para verificar si un cursor devolvió datos

La legibilidad de su código será mayor cuando evite las oraciones negativas.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS 
      SELECT last_name
            ,first_name
        FROM employees
       WHERE commission_pct IS NOT NULL;

   r_employee  c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN NOT c_employees%FOUND;
   END LOOP read_employees;

   CLOSE c_employees;
END;
/

-- GOOD
DECLARE
   CURSOR c_employees IS 
      SELECT last_name
            ,first_name
        FROM employees
       WHERE commission_pct IS NOT NULL;

   r_employee  c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN c_employees%NOTFOUND;
   END LOOP read_employees;

   CLOSE c_employees;
END;
/
```

### G-4120: Evite usar %NOTFOUND directamente después del FETCH cuando trabaje con BULK OPERATIONS y la cláusula LIMIT

%NOTFOUND se establece en VERDADERO tan pronto como se ha leído el número de filas definidas por la cláusula LIMIT.

```sql
-- BAD
/*
La tabla de empleados tiene 107 filas. El ejemplo a continuación solo mostrará 100 filas ya que el atributo de cursor NOTFOUND se establece en verdadero tan pronto como el número de filas a ser definidas por la cláusula límite ya no se cumpla.
*/
DECLARE
   CURSOR c_employees IS 
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      EXIT process_employees WHEN c_employees%NOTFOUND;

      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/

-- BETTER
/*
Este ejemplo mostrará las 107 filas pero ejecutará una búsqueda de más (12 en lugar de 11).

*/
DECLARE
   CURSOR c_employees IS 
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      EXIT process_employees WHEN t_employees.COUNT() = 0;
      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/

-- GOOD
/*
Este ejemplo hace el truco (11 búsquedas solo para procesar todas las filas)
*/

DECLARE
   CURSOR c_employees IS 
      SELECT *
        FROM employees
       ORDER BY employee_id;

   TYPE t_employees_type IS TABLE OF c_employees%ROWTYPE;
   t_employees t_employees_type;
   co_bulk_size CONSTANT SIMPLE_INTEGER := 10;
BEGIN
   OPEN c_employees;

   <<process_employees>>
   LOOP
      FETCH c_employees BULK COLLECT INTO t_employees LIMIT co_bulk_size;
      <<display_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i).last_name);
      END LOOP display_employees;
      EXIT process_employees WHEN t_employees.COUNT() <> co_bulk_size;
   END LOOP process_employees;

   CLOSE c_employees;
END;
/
```

### G-4130: Cerrar siempre los cursores abiertos localmente

Los cursores que queden abiertos pueden consumir espacio de memoria adicional (es decir, SGA) dentro de la instancia de la base de datos, potencialmente en las agrupaciones SQL compartidas y privadas. Además, si no se cierran explícitamente los cursores, la sesión propietaria excederá su límite máximo de cursores abiertos (como se especifica en el parámetro de inicialización de la base de datos **OPEN_CURSORS**), lo que potencialmente resultará en el error de Oracle de "ORA-01000: Máximo número de cursores abiertos exedidos".

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)
      RETURN NUMBER IS
      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS 
         SELECT sum(salary) AS sum_salary
           FROM employees
          WHERE department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   BEGIN
      OPEN c_department_salary(p_dept_id => in_dept_id);
      FETCH c_department_salary INTO r_department_salary;

      RETURN r_department_salary.sum_salary;
   END department_salary;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   FUNCTION department_salary (in_dept_id IN departments.department_id%TYPE)
      RETURN NUMBER IS
      CURSOR c_department_salary(p_dept_id IN departments.department_id%TYPE) IS 
         SELECT SUM(salary) AS sum_salary
           FROM employees
          WHERE department_id = p_dept_id;
      r_department_salary c_department_salary%rowtype;
   BEGIN
      OPEN c_department_salary(p_dept_id => in_dept_id);
      FETCH c_department_salary INTO r_department_salary;
      CLOSE c_department_salary;
      RETURN r_department_salary.sum_salary;
   END department_salary;
END employee_api;
/
```

### G-4140: Evite ejecutar cualquier declaración entre una operación de SQL y el uso de un atributo de cursor implícito

Oracle proporciona una variedad de atributos de cursor (como %FOUND y %ROWCOUNT) que se pueden usar para obtener información sobre el estado de un cursor, ya sea implícito o explícito.

Debe evitar insertar cualquier declaración entre el funcionamiento del cursor y el uso de un atributo contra ese cursor. La interposición de dicha instrucción puede afectar al valor devuelto por el atributo, lo que potencialmente corrompe la lógica del programa.

En el ejemplo siguiente, se inserta una llamada de procedimiento entre la instrucción DELETE y una comprobación del valor de SQL%ROWCOUNT, que devuelve el número de filas modificadas por la última instrucción SQL ejecutada en la sesión. Si este procedimiento incluye un COMMIT/ROLLBACK u otro cursor implícito, el valor de SQL%ROWCOUNT se verá afectado.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   co_one CONSTANT SIMPLE_INTEGER := 1;

   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS
   BEGIN
      NULL;
   END process_dept;

   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS
      l_dept_id      employees.department_id%TYPE;
   BEGIN
      DELETE FROM employees
       WHERE employee_id = in_employee_id
       RETURNING department_id INTO l_dept_id;

      process_dept(in_dept_id => l_dept_id);

      IF SQL%ROWCOUNT > co_one THEN
         -- too many rows deleted. 
         ROLLBACK;
      END IF;
   END remove_employee;
END employee_api;
/

-- GOOD
CREATE OR REPLACE PACKAGE BODY employee_api AS
   co_one CONSTANT SIMPLE_INTEGER := 1;

   PROCEDURE process_dept(in_dept_id IN departments.department_id%TYPE) IS
   BEGIN
      NULL;
   END process_dept;

   PROCEDURE remove_employee (in_employee_id IN employees.employee_id%TYPE) IS
      l_dept_id      employees.department_id%TYPE;
      l_deleted_emps SIMPLE_INTEGER;
   BEGIN
      DELETE FROM employees
       WHERE employee_id = in_employee_id
       RETURNING department_id INTO l_dept_id;

      l_deleted_emps := SQL%ROWCOUNT;

      process_dept(in_dept_id => l_dept_id);

      IF l_deleted_emps > co_one THEN
         -- too many rows deleted. 
         ROLLBACK;
      END IF;
   END remove_employee;
END employee_api;
/
```

## CASE / IF / DECODE / NVL / NVL2 / COALESCE

### G-4210: Intente utilizar CASE en lugar de una instrucción IF con varias rutas de ELSIF

Las declaraciones IF que contienen múltiples ELSIF tienden a volverse complejas rápidamente.

### G-4220: Trate de usar CASE en lugar de DECODE

DECODE es una función específica de ORACLE difícil de entender y restringida a SQL solamente. La función CASE "más nueva" es mucho más común, tiene una mejor legibilidad y también se puede utilizar en PL/SQL.

```sql
-- BAD
SELECT DECODE(dummy, 'X', 1 
                      , 'Y', 2
                      , 'Z', 3
                      , 0)
        FROM dual;

-- GOOD
    SELECT CASE dummy
          WHEN 'X' THEN 1
          WHEN 'Y' THEN 2
          WHEN 'Z' THEN 3
          ELSE 0
    END
  FROM dual;
```

### G-4230: Siempre use un COALESCE en lugar de un comando NVL, si el parámetro 2 de la función NVL es una llamada de función o una instrucción SELECT

La función NVL siempre evalúa ambos parámetros antes de decidir cuál utilizar. Esto puede ser perjudicial si el parámetro 2 es una llamada de función o una instrucción SELECT, ya que se ejecutará independientemente de si el parámetro 1 contiene un valor 
NULL o no.

La función COALESCE no tiene este inconveniente.

```sql
-- BAD
SELECT NVL(dummy, my_package.expensive_null(value_in => dummy))
  FROM dual;

-- GOOD
SELECT COALESCE(dummy, my_package.expensive_null(value_in => dummy))
  FROM dual;
```

### G-4240: Siempre use un CASE en lugar de un comando NVL2 si el parámetro 2 o 3 de NVL2 es una llamada de función o una instrucción SELECT

La función NVL2 siempre evalúa todos los parámetros antes de decidir cuál utilizar. Esto puede ser perjudicial, si el parámetro 2 o 3 es una llamada de función o una instrucción SELECT, ya que se ejecutarán independientemente de si el parámetro 1 contiene un valor NULL o no.

```sql
-- BAD
SELECT NVL2(dummy, my_package.expensive_nn(value_in => dummy), 
                   my_package.expensive_null(value_in => dummy))
  FROM dual;

-- GOOD
SELECT CASE
          WHEN dummy IS NULL THEN 
             my_package.expensive_null(value_in => dummy)
          ELSE 
             my_package.expensive_nn(value_in => dummy)
       END
FROM dual;
```

## Control de flujo

### G-4310: Nunca use declaraciones GOTO en su código

El código que contiene GOTOs es difícil de formatear. La sangría se debe usar para mostrar la estructura lógica y los GOTOs tienen un efecto en la estructura lógica. Tratar de usar la sangría para mostrar la estructura lógica de un goto, sin embargo, es difícil o imposible.

```sql
-- BAD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS 
      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';
      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
      co_errno       CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
      l_isdigit      BOOLEAN     := FALSE;
      l_len_pw       PLS_INTEGER;
      l_len_array    PLS_INTEGER;
   BEGIN
      l_len_pw    := LENGTH(in_password);
      l_len_array := LENGTH(co_digitarray);

      <<check_digit>>
      FOR i IN co_lower_bound .. l_len_array
      LOOP
         <<check_pw_char>>
         FOR j IN co_lower_bound .. l_len_pw
         LOOP
            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN
               l_isdigit := TRUE;
               GOTO check_other_things;
            END IF;
         END LOOP check_pw_char;
      END LOOP check_digit;

      <<check_other_things>>
      NULL;

      IF NOT l_isdigit THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/

-- BETTER
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS 
      co_digitarray  CONSTANT STRING(10 CHAR)   := '0123456789';
      co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
      co_errno       CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg      CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
      l_isdigit      BOOLEAN     := FALSE;
      l_len_pw       PLS_INTEGER;
      l_len_array    PLS_INTEGER;
   BEGIN
      l_len_pw    := LENGTH(in_password);
      l_len_array := LENGTH(co_digitarray);

      <<check_digit>>
      FOR i IN co_lower_bound .. l_len_array
      LOOP
         <<check_pw_char>>
         FOR j IN co_lower_bound .. l_len_pw
         LOOP
            IF SUBSTR(in_password, j, 1) = SUBSTR(co_digitarray, i, 1) THEN
               l_isdigit := TRUE;
               EXIT check_digit; -- early exit condition
            END IF;
         END LOOP check_pw_char;
      END LOOP check_digit;

      <<check_other_things>>
      NULL;

      IF NOT l_isdigit THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/
-- GOOD
CREATE OR REPLACE PACKAGE BODY my_package IS
   PROCEDURE password_check (in_password IN VARCHAR2) IS
      co_digitpattern CONSTANT STRING(10 CHAR)   := '\d';
      co_errno        CONSTANT SIMPLE_INTEGER := -20501;
      co_errmsg       CONSTANT STRING(100 CHAR)  := 'Password must contain a digit.';
   BEGIN
      IF NOT REGEXP_LIKE(in_password, co_digitpattern) 
      THEN
         raise_application_error(co_errno, co_errmsg);
      END IF;
   END password_check;
END my_package;
/
```

### G-4320: Etiqueta siempre tus bucles

```sql
-- BAD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   WHILE (i <= co_max_value) 
   LOOP 
      i := i + co_increment; 
   END LOOP;

   LOOP 
      EXIT;
   END LOOP;

   FOR i IN co_min_value..co_max_value
   LOOP 
      sys.dbms_output.put_line(i);
   END LOOP;

   FOR r_employee IN (SELECT last_name FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP;   
END;
/

-- GOOD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value) 
   LOOP 
      i := i + co_increment; 
   END LOOP while_loop;

   <<basic_loop>>
   LOOP 
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP 
      sys.dbms_output.put_line(i);
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP process_employees;
END;
/
```

### G-4330: Utilice siempre un bucle CURSOR FOR para procesar los resultados completos del cursor a menos que esté utilizando operaciones masivas

Es más fácil para el lector ver que se procesa el conjunto de datos completo. El uso de SQL para definir los datos a procesar es más fácil de mantener y, por lo general, más rápido que usar el procesamiento condicional dentro del bucle.

Dado que una instrucción EXIT es similar a una instrucción GOTO, debe evitarse siempre que sea posible.

```sql
-- BAD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;

   <<read_employees>>
   LOOP
      FETCH c_employees INTO r_employee;
      EXIT read_employees WHEN c_employees%NOTFOUND;
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP read_employees;

   CLOSE c_employees;
END;
/

-- GOOD
DECLARE
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
BEGIN
   <<read_employees>>
   FOR r_employee IN c_employees
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
   END LOOP read_employees;
END;
/
```

### G-4340: Siempre use un bucle NUMERIC FOR para procesar una matriz densa

Es más fácil para el lector ver que se procesa la matriz completa.

Dado que una instrucción EXIT es similar a una instrucción GOTO, debe evitarse siempre que sea posible.

```sql
-- BAD
DECLARE
   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_himuro     CONSTANT INTEGER := 118;
   co_livingston CONSTANT INTEGER := 177;
   co_min_value  CONSTANT SIMPLE_INTEGER := 1;
   co_increment  CONSTANT SIMPLE_INTEGER := 1;
   i PLS_INTEGER;
BEGIN
   t_employees := t_employee_type(co_himuro, co_livingston);
   i           := co_min_value;

   <<process_employees>>
   LOOP
      EXIT process_employees WHEN i > t_employees.COUNT();
      sys.dbms_output.put_line(t_employees(i));
      i := i + co_increment;
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   TYPE t_employee_type IS VARRAY(10) OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_himuro     CONSTANT INTEGER := 118;
   co_livingston CONSTANT INTEGER := 177;
BEGIN
   t_employees := t_employee_type(co_himuro, co_livingston);

   <<process_employees>>
   FOR i IN 1..t_employees.COUNT()
   LOOP
     sys.dbms_output.put_line(t_employees(i));
   END LOOP process_employees;
END;
/
```

### G-4350: Siempre use 1 como inferior y COUNT() como límite superior cuando realice un bucle a través de una matriz densa

Al hacerlo, no se generará un VALUE_ERROR si la matriz a través de la cual está circulando está vacía. Si desea utilizar FIRST() ... LAST(), debe verificar la matriz en busca de vacío de antemano para evitar el aumento de VALUE_ERROR.

```sql
-- BAD
DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   <<process_employees>>
   FOR i IN t_employees.FIRST()..t_employees.LAST()
   LOOP
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   END LOOP process_employees;
END;
/
-- BETTER
/*
Lance un error de colección unificada si t_employees no está inicializado.
*/

DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   <<process_employees>>
   FOR i IN 1..t_employees.COUNT()
   LOOP
      sys.dbms_output.put_line(t_employees(i)); -- some processing
   END LOOP process_employees;
END;
/

-- GOOD
/*
No genera un error ni comprueba si la matriz está vacía. t_employees.COUNT() siempre devuelve un NÚMERO (a menos que la matriz no esté inicializada). Si la matriz está vacía, COUNT() devuelve 0 y, por lo tanto, el bucle no se ingresará.
*/

DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type := t_employee_type();
BEGIN
   IF t_employees IS NOT NULL THEN
      <<process_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i)); -- some processing
      END LOOP process_employees;
   END IF;
END;
/
```

### G-4360: Siempre use un bucle WHILE para procesar una matriz suelta

Cuando se procesa una matriz suelta utilizando un bucle numérico para que tengamos que comprobar con todas las iteraciones si el elemento existe para evitar una excepción NO_DATA_FOUND. 

Además, el número de iteraciones no está impulsado por el número de elementos de la matriz, sino por el número del elemento más bajo o más alto. Cuantas más saltos tengamos, más iteraciones superfluas se realizarán.

```sql
-- BAD
DECLARE -- raises no_data_found when processing 2nd record
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_rogers      CONSTANT INTEGER := 134;
   co_matos       CONSTANT INTEGER := 143;
   co_mcewen      CONSTANT INTEGER := 158;
   co_index_matos CONSTANT INTEGER := 2;
BEGIN
   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);
   t_employees.DELETE(co_index_matos);

   IF t_employees IS NOT NULL THEN
      <<process_employees>>
      FOR i IN 1..t_employees.COUNT()
      LOOP
         sys.dbms_output.put_line(t_employees(i));
      END LOOP process_employees;
   END IF;
END;
/

-- GOOD
DECLARE
   TYPE t_employee_type IS TABLE OF employees.employee_id%TYPE;
   t_employees t_employee_type;
   co_rogers      CONSTANT INTEGER := 134;
   co_matos       CONSTANT INTEGER := 143;
   co_mcewen      CONSTANT INTEGER := 158;
   co_index_matos CONSTANT INTEGER := 2;
   l_index        PLS_INTEGER;
BEGIN
   t_employees := t_employee_type(co_rogers, co_matos, co_mcewen);
   t_employees.DELETE(co_index_matos);

   l_index := t_employees.FIRST();

   <<process_employees>>
   WHILE l_index IS NOT NULL
   LOOP
      sys.dbms_output.put_line(t_employees(l_index));
      l_index := t_employees.NEXT(l_index);
   END LOOP process_employees;
END;
/
```

### G-4370: Evite utilizar EXIT para detener el procesamiento del bucle a menos que esté en un bucle básico

Un numérico para bucle así como un bucle while y un cursor para bucle tienen límites de bucle definidos. Si no puede salir de su bucle utilizando esos límites de bucle, entonces un bucle básico es el bucle correcto para elegir.

```sql
-- BAD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value) 
   LOOP 
      i := i + co_increment; 
      EXIT while_loop WHEN i > co_max_value;
   END LOOP while_loop;

   <<basic_loop>>
   LOOP 
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP 
      NULL;
      EXIT for_loop WHEN i = co_max_value;
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name);
      NULL; -- some processing
      EXIT process_employees;
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   i INTEGER;
   co_min_value CONSTANT SIMPLE_INTEGER := 1;
   co_max_value CONSTANT SIMPLE_INTEGER := 10;
   co_increment CONSTANT SIMPLE_INTEGER := 1;
BEGIN
   i := co_min_value;
   <<while_loop>>
   WHILE (i <= co_max_value) 
   LOOP 
      i := i + co_increment; 
   END LOOP while_loop;

   <<basic_loop>>
   LOOP 
      EXIT basic_loop;
   END LOOP basic_loop;

   <<for_loop>>
   FOR i IN co_min_value..co_max_value
   LOOP 
      sys.dbms_output.put_line(i);
   END LOOP for_loop;

   <<process_employees>>
   FOR r_employee IN (SELECT last_name
                        FROM employees)
   LOOP
      sys.dbms_output.put_line(r_employee.last_name); -- some processing
   END LOOP process_employees;
END;
/
```

### G-4375: Utilice siempre EXIT WHEN en lugar de una instrucción IF para salir de un bucle

Si necesita usar una instrucción EXIT, use su semántica completa para que el código sea más fácil de entender y mantener. Simplemente no hay necesidad de una declaración IF adicional.

```sql
-- BAD
DECLARE
   co_first_year CONSTANT PLS_INTEGER := 1900;
BEGIN
   <<process_employees>>
   LOOP
      my_package.some_processing();

      IF EXTRACT(year FROM SYSDATE) > co_first_year THEN
         EXIT process_employees;
      END IF;

      my_package.some_further_processing();
   END LOOP process_employees;
END;
/

-- GOOD
DECLARE
   co_first_year CONSTANT PLS_INTEGER := 1900;
BEGIN
   <<process_employees>>
   LOOP
      my_package.some_processing();

      EXIT process_employees WHEN EXTRACT(YEAR FROM SYSDATE) > co_first_year;

      my_package.some_further_processing();
   END LOOP process_employees;
END;
/
```

### G-4380 Trate de etiquetar sus declaraciones EXIT WHEN

Es una buena alternativa para los comentarios, especialmente para los bucles anidados para nombrar el bucle para salir.

```sql
-- BAD
DECLARE
   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;
   co_increment  CONSTANT SIMPLE_INTEGER           := 1;
   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;
   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp PLS_INTEGER;
   l_innerlp PLS_INTEGER;
BEGIN
   l_outerlp := co_init_loop;
   <<outerloop>>
   LOOP
      l_innerlp := co_init_loop;
      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;
      <<innerloop>>
      LOOP
         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text || l_outerlp ||
                                  co_inner_text || l_innerlp);

         EXIT WHEN l_innerlp = co_exit_value;
      END LOOP innerloop;

      EXIT WHEN l_innerlp = co_exit_value;
   END LOOP outerloop;
END;
/

-- GOOD
DECLARE
   co_init_loop  CONSTANT SIMPLE_INTEGER           := 0;
   co_increment  CONSTANT SIMPLE_INTEGER           := 1;
   co_exit_value CONSTANT SIMPLE_INTEGER           := 3;
   co_outer_text CONSTANT types_up.short_text_type := 'Outer Loop counter is ';
   co_inner_text CONSTANT types_up.short_text_type := ' Inner Loop counter is ';
   l_outerlp PLS_INTEGER;
   l_innerlp PLS_INTEGER;
BEGIN
   l_outerlp := co_init_loop;
   <<outerloop>>
   LOOP
      l_innerlp := co_init_loop;
      l_outerlp := NVL(l_outerlp,co_init_loop) + co_increment;
      <<innerloop>>
      LOOP
         l_innerlp := NVL(l_innerlp, co_init_loop) + co_increment;
         sys.dbms_output.put_line(co_outer_text || l_outerlp ||
                                  co_inner_text || l_innerlp);

         EXIT outerloop WHEN l_innerlp = co_exit_value;
      END LOOP innerloop;
   END LOOP outerloop;
END;
/
```

### G-4385: Nunca utilice un cursor para el bucle para comprobar si un cursor devuelve datos

Puede procesar más datos de los necesarios, lo que conduce a un mal rendimiento.

```sql
-- BAD
DECLARE
   l_employee_found BOOLEAN := FALSE;
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
BEGIN
   <<check_employees>>
   FOR r_employee IN c_employees
   LOOP
      l_employee_found := TRUE;
   END LOOP check_employees;
END;
/

-- GOOD
DECLARE
   l_employee_found BOOLEAN := FALSE;
   CURSOR c_employees IS
      SELECT employee_id, last_name
        FROM employees;
   r_employee c_employees%ROWTYPE;
BEGIN
   OPEN c_employees;
   FETCH c_employees INTO r_employee;
   l_employee_found := c_employees%FOUND;
   CLOSE c_employees;
END;
/
```

### G-4390: Evite el uso de índices de bucles FOR sin referencia

Si el índice de bucle se usa para cualquier cosa que no sea el control de tráfico dentro del bucle, este es uno de los indicadores de que un bucle FOR numérico se está utilizando incorrectamente. El cuerpo real de las instrucciones ejecutables ignora completamente el índice de bucle. Cuando ese es el caso, es muy probable que no necesite el bucle en absoluto.

```sql
-- BAD
DECLARE
   l_row   PLS_INTEGER;
   l_value PLS_INTEGER;
   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;
   co_row_incr    CONSTANT SIMPLE_INTEGER           := 1;
   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;
   co_delimiter   CONSTANT types_up.short_text_type := ' ';
   co_first_value CONSTANT SIMPLE_INTEGER           := 100;
BEGIN
   l_row := co_lower_bound;
   l_value := co_first_value;
   <<for_loop>>
   FOR i IN co_lower_bound .. co_upper_bound
   LOOP
      sys.dbms_output.put_line(l_row || co_delimiter || l_value);
      l_row   := l_row + co_row_incr;
      l_value := l_value + co_value_incr;
   END LOOP for_loop;
END;
/

-- GOOD
DECLARE
   co_lower_bound CONSTANT SIMPLE_INTEGER           := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER           := 5;
   co_value_incr  CONSTANT SIMPLE_INTEGER           := 10;
   co_delimiter   CONSTANT types_up.short_text_type := ' ';
   co_first_value CONSTANT SIMPLE_INTEGER           := 100;
BEGIN
   <<for_loop>>
   FOR i IN co_lower_bound .. co_upper_bound
   LOOP
      sys.dbms_output.put_line(i || co_delimiter ||
                               to_char(co_first_value + i * co_value_incr));
   END LOOP for_loop;
END;
/
```

### G-4395: Evite los valores de límite superior o inferior codificados mediante el uso de bucles FOR

Su declaración LOOP utiliza un valor codificado para sus límites superior o inferior. Esto crea un "enlace débil" en su programa porque asume que este valor nunca cambiará. Una práctica mejor es crear una constante (o función) con nombre y hacer referencia a este elemento con nombre en lugar del valor codificado.

```sql
-- BAD
BEGIN
   <<for_loop>>
   FOR i IN 1..5
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/

-- GOOD
DECLARE
   co_lower_bound CONSTANT SIMPLE_INTEGER := 1;
   co_upper_bound CONSTANT SIMPLE_INTEGER := 5;
BEGIN
   <<for_loop>>
   FOR i IN co_lower_bound..co_upper_bound
   LOOP
      sys.dbms_output.put_line(i);
   END LOOP for_loop;
END;
/
```

## Manejo de excepciones

